{"date_published": "2010-11-14", "author": "phn", "description": "PyFITS: FITS files in Python - part 2PyFITS has many methods that provide more control over manipulating FITS files, than that provided by the convenience functions discussed in\u00a0part 1 of this article. In the following sections we discuss several of these methods.ContentsHDUList\nHDU object\nHeader\nCard object and card lists\nCreating a new header\n\nData\nImage data\nTables\nCreating a new FITS table\n\nFinally\n\nHDUListPyFITS treats a FITS file as a collection of\u00a0HDU objects, each of which represents a FITS HDU. The function\u00a0pyfits.open\u00a0returns an\u00a0HDUList\u00a0object, which is a collection of all the HDU objects in the FITS file.>>> hdulist = pyfits.open(\"WFPC2u5780205r_c0fx.fits\")\n>>> type(hdulist)\n<class 'pyfits.core.HDUList'>\n>>> len(hdulist)\n2\n>>> hdulist.info()\nFilename: WFPC2u5780205r_c0fx.fits\nNo.  Name     Type   Cards  Dimensions  Format\n0  PRIMARY   PrimaryHDU   262 (200, 200, 4) float32\n1  U5780205R_CVT.C0H.TAB TableHDU    353 4R x 49C ['D25.17',\n 'D25.17', 'E15.7', 'E15.7', 'E15.7', 'E15.7', 'E15.7',\n 'E15.7', 'E15.7', 'E15.7', 'A1', 'E15.7', 'I12', 'I12', 'D25.17',\n 'D25.17', 'A8', 'A8', 'I12', 'E15.7', 'E15.7', 'E15.7', 'E15.7',\n 'E15.7', 'E15.7', 'I12', 'I12', 'I12', 'I12', 'I12', 'I12', 'I12',\n 'I12', 'A48', 'E15.7', 'E15.7', 'E15.7', 'E15.7', 'E15.7',\n 'E15.7', 'E15.7', 'E15.7', 'E15.7', 'E15.7', 'E15.7', 'E15.7',\n 'E15.7', 'E15.7', 'E15.7']\nThis function takes a parameter,\u00a0mode, that will set the mode in which the file is opened, based on the string passed as its value:mode stringfile modecopyonwriterbreadonlyrbupdaterb+appendab+ostreamwIf we plan to modify the file then it should be opened with the appropriate mode string passed to\u00a0pyfits.open, using the\u00a0mode\u00a0parameter.HDU objectTo access an HDU object in the HDUList, treat the latter as a list or as a dictionary with the extension names as keys.>>> hdu0 = hdulist[0]\n>>> type(hdu0)\n<class 'pyfits.core.PrimaryHDU'>\n>>> for i in hdulist: print i.name\n....\nPRIMARY\nU5780205R_CVT.C0H.TAB\n>>> del i\n>>> hdulist['primary'] is hdulist[0]\nTrue\n>>> hdulist['u5780205r_cvt.c0h.tab'] is hdulist[1]\nTrue\n>>> hdu1 = hdulist[1]\n>>> type(hdu1)\n<class 'pyfits.core.TableHDU'>\nAn HDU object has a\u00a0header\u00a0attribute and a\u00a0data\u00a0attribute, which contain the FITS header and data, respectively, of the FITS HDU.HeaderThe header of an extension is stored in the\u00a0header\u00a0attribute of the corresponding HDU object.>>> header0 = hdu0.header\n>>> header1 = hdu1.header\nIn PyFITS, a header is a dictionary like object with FITS keywords as keys. A header can also be treated like a list. This feature is needed to access keywords that can occur multiple times in a header, for example\u00a0COMMENT; dictionary syntax will extract only the first occurrence. Headers support only simple indexing, i.e., no slices.>>> header0.keys()\n['SIMPLE',\n'BITPIX',\n'NAXIS',\n'NAXIS1',\n'NAXIS2',\n'NAXIS3',\n'EXTEND',\n'COMMENT',\n...\n>>> header1.keys()\n['XTENSION',\n'BITPIX',\n'NAXIS',\n'NAXIS1',\n'NAXIS2',\n'PCOUNT',\n'GCOUNT',\n'TFIELDS',\n'EXTNAME',\n...\n>>> header0['ra_targ']\n182.63550000000001\n>>> header0['gal_long']\n155.079532\n>>> header1['NAXIS']\n2\n>>> header1['naxis'] # Case insensitive\n2\n>>> header1['naxis2']\n4\n>>> header1['tfields']\n49\nKeyword values in a header can be changed, and new keywords can be added using the\u00a0update\u00a0method of the\u00a0header:>>> header1.update(\"Author\", \"I Me Myself\", \"Name\")\n>>> header1['author']\n'I Me Myself'\n>>> del header1['author']\n>>> header1['author']\n...\nKeyError: \"Keyword 'author' not found.\"\nThe changes occur only in memory and so, in order to make the changes permanent, the FITS file must be written to disk.To add new\u00a0HISTORY,\u00a0COMMENT\u00a0and blank records use the appropriately named methods of the header object. Blank records will be placed at the end of the header, whileCOMMENT\u00a0and\u00a0HISTORY\u00a0records will be placed immediately after the last occurrence of the keyword, unless an explicit position is given.>>> header1.add_history(\"Changing history\")\n>>> header1.add_blank(\"A blank record. No keyword\")\n>>> header1.add_comment(\"A new comment line.\")\n>>> header1.add_comment(\"Some comment\", before='histwide')\n>>> header1.add_comment(\"Some more\", after='skewness')\n>>> header1.keys()\n...\n'MEDSHADO',\n'COMMENT',\n'HISTWIDE',\n'SKEWNESS',\n'MEANC10',\n'MEANC25'\n...\nThe\u00a0before\u00a0and\u00a0after\u00a0argument can also be integers, in which case they will be used as list index numbers.From the above output, we can see that only the first\u00a0COMMENT\u00a0record can be accessed using a dictionary key. To see that we have indeed added a second\u00a0COMMENT\u00a0record after the\u00a0SKEWNESS\u00a0record , we can print the header or use the\u00a0get_comment\u00a0method of the header object. The latter returns all the\u00a0COMMENT\u00a0records as a list of strings. The method\u00a0get_history\u00a0extracts all\u00a0HISTORY\u00a0records.>>> print header1\n...\nMEDSHADO= 'median pixel value in shadow of pyramid edge' /\nCOMMENT Some comment\nHISTWIDE= 'width of the histogram' /\nSKEWNESS= 'skewness of the histogram' /\nCOMMENT Some more\nMEANC10 = 'mean of a 10x10 region at center of chip' /\n...\n>>> header1.get_comment()\n[\" FITS (Flexible Image Transport System) format is defined in 'Astronomy\",\n\" and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H\",\n'A new comment line.',\n'Some comment',\n'Some more']\nThe following code can be used to find the position of a\u00a0COMMENT\u00a0card in a\u00a0Card List. The\u00a0ascardlist\u00a0method is explained in the\u00a0Card object and card lists\u00a0section:>>> for i, card in enumerate(header1.ascardlist()):\n ....:   if card.key == 'COMMENT':\n ....:     print i, card.key, card.value, card.comment\n ....:\n ....:\n7 COMMENT  FITS (Flexible Image Transport System) format is defined in 'Astronomy\n8 COMMENT  and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H\n9 COMMENT A new comment line.\n60 COMMENT Some comment\n63 COMMENT Some more\nTo get all the blank records we can check to see if a card object in a card list has a blank key:>>> for i, card in enumerate(header1.ascardlist()):\n....:  if card.key == \"\":\n....:    print i, card.value, card.comment\n....:\n75\n79\n80    / WFPC-II DATA DESCRIPTOR KEYWORDS\n81\n86\n87    / SCIENCE INSTRUMENT CONFIGURATION\n88\n...\n185\n192\n193    / EXPOSURE INFORMATION\n194\n199\n206\n207    / TARGET & PROPOSAL ID\n215\n>>> print data_header_cards[205:210]\nEXPFLAG = 'NORMAL    '   / Exposure interruption indicator\n\n       / TARGET & PROPOSAL ID\nTARGNAME= 'NGC4151            ' / proposer's target name\nRA_TARG =  1.826355000000E+02 / right ascension of the target (deg) (J2000)\nCard object and card listsA header itself consists of\u00a0Card Objects, each representing a record in the FITS header. The list of card object in a header can be obtained using the\u00a0ascardlist\u00a0function of the header object.>>> card_list = header1.ascardlist()\n>>> len(card_list)\n>>> cardlist.keys()\n...\n...\n>>> type(card_list)\n<class 'pyfits.core.CardList'>\n>>> card_list['BITPIX']\nBITPIX =          8 / 8-bits per 'pixels'\n>>> card_list[1]\nBITPIX =          8 / 8-bits per 'pixels'\nUnlike the\u00a0Header\u00a0object, a card list supports list slicing:>>> card_list[0:10].keys()\n['XTENSION',\n 'BITPIX',\n 'NAXIS',\n 'NAXIS1',\n 'NAXIS2',\n 'PCOUNT',\n 'GCOUNT',\n 'TFIELDS',\n 'EXTNAME',\n '']\nThe maximum length of a standard FITS keyword is 8 characters and each record can have a maximum of 80 characters. There are two keywords that can be used to overcome these limitations:\u00a0HIERARCH\u00a0and\u00a0CONTINUE. See pages 19 and 20 of the\u00a0PyFITS Handbook, for more information.Each object in a card list is a\u00a0Card Image. A Card Image represents one FITS header record.>>> a_card = card_list[0]\n>>> type(a_card)\n<class 'pyfits.core.Card'>\n>>> print a_card\nXTENSION= 'TABLE  '      / Ascii table extension\nA Card object has three main attributes:\u00a0key,\u00a0value\u00a0and\u00a0comment. They represent the keyword name, the value and the comment of the corresponding FITS record, respectively.>>> a_card.key\n'XTENSION'\n>>> a_card.value\n'TABLE'\n>>> a_card.comment\n'Ascii table extension'\nCreating a new headerThere are two ways of creating a new FITS header: create an empty header and use its\u00a0update\u00a0method to add records, or create a list of Card images and then create a header by passing this list to the\u00a0pyfits.Header\u00a0constructor.The following illustrates the first method:>>> header_0 = pyfits.Header()\n>>> header_0.update(key=\"simple\", value=\"T\", comment=\"Conforms to standard\")\n>>> header_0.update(key=\"bitpix\", value=32)\n>>> header_0.update(key=\"date\", value=\"2010-10-10\")\n>>> header_0.update(key=\"origin\", value=\"kpno\", comment=\"2010B: Prj. X\")\n>>> print header_0\nSIMPLE = 'T    '      / Conforms to standard\nBITPIX =          32\nDATE  = '2010-10-10'\nORIGIN = 'kpno  '      / 2010B: Prj. X\nA Card object can be created using the\u00a0pyfits.Card\u00a0constructor. The constructor takes as arguments, a key, a value and a comment. Note that within PyFITS, keywords are case insensitive. Also, the constructor will check if the resultant FITS record is valid or not. If for some reason, we want to create non-conforming Cards, then use thepyfits.Card().fromstring\u00a0method.>>> card_0 = pyfits.Card(\"simple\", \"T\")\n>>> card_1 = pyfits.Card(\"bitpix', -32)\n>>> card_2 = pyfits.Card(\"date\", \"2010-10-10\")\n>>> card_3 = pyfits.Card(\"origin\", \"kpno\", \"2010B run for Prj. X\")\n>>> card_4 = pyfits.Card(\"dddddddddddddddddddddd\",\"123\", \"222\")\n...\nValueError: keyword name dddddddddddddddddddddd is too long (> 8), use HIERARCH.\n>>> print card_0\nSIMPLE = 'T    '\n>>> print card_1\nBITPIX =         -32\n>>> print card_2\nDATE  = '2010-10-10'\n>>> print card_3\nORIGIN = 'kpno  '      / 2010B: Prj. X\nThe\u00a0verify\u00a0method of a Card object can be used to verify that it conforms to the FITS standard.If the header is going to be part of an extension, rather than the Primary HDU, then add the keyword \"XTENSION\", with value set to \"IMAGE\", \"TABLE\" or \"BINTABLE\", as appropriate.Once we have a set of Cards, we can create a header by passing the list of Cards to the\u00a0pyfits.Header\u00a0constructor.>>> card_list = [card_0, card_1, card_2, card_3]\n>>> header_0 = pyfits.Header(cards=card_list)\n>>> print header_0\nSIMPLE = 'T '\nBITPIX = -32\nDATE = '2010-10-10'\nORIGIN = 'kpno ' / 2010B: Prj. X\nDataAs mentioned before, a FITS HDU consists of a data part and a header part. The data part can be accessed through the\u00a0data\u00a0attribute of a HDU object. In the Primary HDU and extensions with\u00a0XTENSION = IMAGE, the data part can be a multi-dimensional array. Extensions with\u00a0XTENSION = TABLE\u00a0and\u00a0XTENSION = BINTABLE, will contain tabular data in ASCII and binary formats, respectively.Image dataImage data consists of a multi-dimensional array, and can occur as the data part of the Primary HDU or an extension HDU with\u00a0XTENSION = IMAGE. In PyFITS the image data is stored as numpy arrays. The dimensions and data type of this array must match the appropriate keywords in the header.To create a Primary HDU with image data we can use the\u00a0pyfits.PrimaryHDU\u00a0constructor.>>> data = numpy.zeros((2,4,3), dtype=numpy.float64)\n>>> primary_hdu = pyfits.PrimaryHDU(data=data, header=header_0)\n>>> print primary_hdu.header\nSIMPLE = T / conforms to FITS standard\nBITPIX = -64 / array data type\nNAXIS = 3 / number of array dimensions\nNAXIS1 = 3\nNAXIS2 = 4\nNAXIS3 = 2\nDATE = '2010-10-10'\nORIGIN = 'kpno ' / 2010B: Prj. X\nThe header,\u00a0header_0, is the same as that in the\u00a0creating a new header\u00a0section of this document; PyFITS has automatically changed the\u00a0BITPIX\u00a0value to reflect the actual data type, and has also inserted the\u00a0NAXIS\u00a0and\u00a0NAXISn\u00a0keywords to store information on the dimensions of the data. It has also added comments to the keyword\u00a0SIMPLE.See page 22 of the\u00a0PyFITS Handbook\u00a0for information on how to handle \"scaled\" data. Page 24 of the document lists methods for working with large data sets.TablesThe header associated with a table extension stores meta-data for the columns in a table, in addition to the regular FITS header records. Some of the metadata stored are:FITS keywordPropertyNAXIS2Number of rowsTFIELDSNumber of columnsTFORMnFormat of data in column nTTYPEnName of column nTUNITnUnit for data in column n>>> hdu_list = pyfits.open(\"WFPC2u5780205r_c0fx.fits\")\n>>> table_hdu = hdu_list[1]\n>>> table_header = table_hdu.header\n>>> table_header['tfields']\n49\n>>> table_header['naxis2']\n4\n>>> table_header['tform1']\n'D25.17'\n>>> table_header['tform2']\n'D25.17'\n>>> table_header['tform3']\n'E15.7'\n>>> table_header['ttype1']\n'CRVAL1'\n>>> table_header['ttype2']\n'CRVAL2'\n>>> table_header['ttype3']\n'CRPIX1'\nA table HDU object has a property\u00a0columns, which gives the properties of the columns in the table; this object is a\u00a0ColDefs\u00a0object. A table column stores several properties that describe the data in it:\u00a0name,\u00a0format,\u00a0unit, a display format\u00a0disp,\u00a0null\u00a0values, the data\u00a0array\u00a0and others. Of these, only\u00a0format\u00a0is mandatory.>>> table_hdu.columns\nColDefs(name = 'CRVAL1'\nformat = 'D25.17'\nunit = ' '\ndisp = 'G25.16'\nstart = 1, name = 'CRVAL2'\nformat = 'D25.17'\nunit = ' '\ndisp = 'G25.16'\nstart = 27, name = 'CRPIX1'\nformat = 'E15.7'\nunit = ' '\ndisp = 'G15.7'\nstart = 53, name = 'CRPIX2'\n...\nData in tables, both ASCII and binary tables, are stored using a data type similar to\u00a0numpy record arrays. The data part of the table has several properties that can be used to extract rows and columns from the table.>>> table_data = table_hdu.data\n>>> table_data.field(0) # First column\narray([ 182.63118863, 182.62552336, 182.65237923, 182.65002236])\n>>> table_hdu.names\n['CRVAL1',\n'CRVAL2',\n'CRPIX1',\n'CRPIX2',\n'CD1_1',\n'CD1_2',\n'CD2_1',\n'CD2_2',\n'DATAMIN',\n'DATAMAX',\n...\n'MEANC100',\n'MEANC200',\n'MEANC300',\n'BACKGRND']\n>>> table_data.field('crval1') # Column named 'crval1'\narray([ 182.63118863, 182.62552336, 182.65237923, 182.65002236])\n>>> table_data['crval1'] # Column named 'crval1'\narray([ 182.63118863, 182.62552336, 182.65237923, 182.65002236])\n>>> table_data[0] # First row\n(182.63118863080001, 39.396336734110001, 420.0, 424.5,\n...\n)\n>>> table_data[0]['crval1'] # First row of column 'crval1'\n182.63118863080001\nSome differences between ASCII and binary tables are as follows:Binary tables can hold all data types allowed in the FITS standard. ASCII tables can only have characters, integers and floating point numbers. It cannot have Boolean and complex numbers.\nThe value in an ASCII table cell must be a scalar. In binary tables, a cell can contain an array.\nThe\u00a0TFORMn\u00a0values differ for ASCII and binary tables.\n\nThe keyword\u00a0TFORMn\u00a0indicates the format of the data stored in column number n.Format codes for ASCII tables:AwCharacter string of width w; w is an integerIwIntegersFw.d32-bit floating point numberEw.d, Dw.d64-bit floating point number, in exponential notationFormat codes for binary tables:LBoolean of length 1 byteBUnsigned byteI, J, K16-bit, 32-bit and 64-bit integers, respectivelyACharactersE, D32-bit and 64-bit floating point numbers, respectivelyC, M32-bit and 64-bit complex numbers, respectivelyFor binary tables, an integer preceding the format codes for numerical types sets the length of data in each cell; a number greater than 1 indicates that the each cell holds a multidimensional data array. An integer preceding or succeeding 'A' indicates the length of the string in each cell of the column.Creating a new FITS tableCreating a new FITS table involves creating several\u00a0Column\u00a0objects, creating a\u00a0ColDefs\u00a0object using these and then creating a\u00a0TableHDU\u00a0or a\u00a0BinTableHDU\u00a0using theColDefs\u00a0object. Since tables can only be present in FITS extensions, an\u00a0HDUList\u00a0is created containing a\u00a0PrimaryHDU\u00a0and the table HDU. The resulting\u00a0HDUList\u00a0can then be written onto the disk. Headers can be provided explicitly; if not present PyFITS will insert a header with appropriate keywords for the table HDU.In the following example, we will create a binary table with 3 columns with names \"target\", \"counts\", and \"spectrum\". The \"target\" column will hold names of objects; a name will be a string of maximum 10 characters. The \"counts\" column will hold 32 bit integer numbers. Each cell in the \"spectrum\" column will hold an array of 1000 floating point numbers. The table will hold data for 4 objects, i.e., 4 rows. We will name the table \"MYTAB\", which will be stored in the header keyword\u00a0EXTNAME.>>> targets = numpy.array(['ngc1', 'ngc2', 'ngc3', 'ngc4'])\n>>> counts = numpy.array([312, 334, 308, 317])\n>>> spectrum = numpy.ones((4,1000), dtype=numpy.float32)\nEach row in the\u00a0spectrum\u00a0array, in the code fragment above, is the \"spectrum\" for an object.PyFITS\u00a0Column\u00a0constructor is used to create columns. This constructor takes as argument a name for the column, a format describing the format of the data and the data array itself.>>> c1 = pyfits.Column(name='target', format='10A', array=targets)\n>>> c2 = pyfits.Column(name=\"counts\", format=\"J\", array=counts)\n>>> c3 = pyfits.Column(name=\"spectrum\", format=\"1000E\", array=spectrum)\nTo create a new table we can use the\u00a0pyfits.new_table\u00a0function. This function will accept\u00a0ColDefs\u00a0object or a list of\u00a0Column\u00a0object. So we don't have to perform the intermediate step of creating a\u00a0ColDefs\u00a0object from\u00a0Column\u00a0object.>>> table_hdu = pyfits.new_table([c1, c2, c3])\n>>> table_hdu.columns\nColDefs(name = 'target'\nformat = '10A', name = 'counts'\nformat = 'J', name = 'spectrum'\nformat = '1000E')\n>>> print table_hdu.header\nXTENSION= 'BINTABLE'      / binary table extension\nBITPIX =          8 / array data type\nNAXIS  =          2 / number of array dimensions\nNAXIS1 =         4014 / length of dimension 1\nNAXIS2 =          4 / length of dimension 2\nPCOUNT =          0 / number of group parameters\nGCOUNT =          1 / number of groups\nTFIELDS =          3 / number of table fields\nTTYPE1 = 'target '\nTFORM1 = '10A   ' TTYPE2 = 'counts '\nTFORM2 = 'J    ' TTYPE3 = 'spectrum'\nTFORM3 = '1000E  ' >>> table_hdu.header['naxis2'] # Number of rows\n4\n>>> table_hdu.header['naxis1'] # Number of bytes in a row = 10 + 4 + 4*1000\n4014\n>>> table_hdu.header['tfields'] # Number of columns\n3\n>>> table_hdu.header['tform1'] # Format of first column\n10A\n>>> table_hdu.header['tform2'] # Format of second column\nJ\n>>> table_hdu.header['tform1'] # Format of third column\n1000E\nNote that PyFITS has automatically inserted the required keywords with proper values. By default the table created is a binary table; pass the keyword\u00a0tbtype\u00a0with value set to\u00a0TableHDU\u00a0to create ASCII tables. To add additional records to the header, we can use the\u00a0update\u00a0method of the header.The\u00a0new_table\u00a0function takes a keyword parameter,\u00a0nrows, that can be used to specify the number of rows in a table. If we need to add more rows, we can create a new table with data from the existing table, and setting\u00a0nrows\u00a0to the desired value. The empty rows can then be filled in with data.>>> table_hdu = pyfits.new_table(table_hdu.data, nrows=10)\n>>> print table_hdu.header\nXTENSION= 'BINTABLE'      / binary table extension\nBITPIX =          8 / array data type\nNAXIS  =          2 / number of array dimensions\nNAXIS1 =         4014 / length of dimension 1\nNAXIS2 =          10 / length of dimension 2\nPCOUNT =          0 / number of group parameters\nGCOUNT =          1 / number of groups\nTFIELDS =          3 / number of table fields\nTTYPE1 = 'target '\nTFORM1 = '10A   '\nTTYPE2 = 'counts '\nTFORM2 = 'J    '\nTTYPE3 = 'spectrum'\nTFORM3 = '1000E  '\n>>> print table_hdu.header['naxis2']\n10\n>>> print table_hdu.data['target']\n['ngc1' 'ngc2' 'ngc3' 'ngc4' '0.0' '0.0' '0.0' '0.0' '0.0' '0.0']\n>>> table_hdu.data[4]['target'] = \"ngc1\"\n>>> print table_hdu.data['target']\n['ngc1' 'ngc2' 'ngc3' 'ngc4' 'ngc5' '0.0' '0.0' '0.0' '0.0' '0.0']\n>>> table_hdu.data[4]['counts'] = 315\n>>> print table_hdu.data['counts']\n[312 334 308 317 315  0  0  0  0  0]\n>>> table_hdu.data[4]['spectrum'] = numpy.random.random(1000)\n>>> print table_hdu.data[4]['spectrum']\n[ 7.87860215e-01  5.22207081e-01  4.59663749e-01  2.55125035e-02\n  1.91508323e-01  9.30920959e-01  7.40450263e-01  6.01666987e-01\n  7.82849014e-01  8.67393970e-01  7.16790557e-02  5.63477933e-01\n  ...\n  4.05643554e-03  9.19736564e-01  8.43929410e-01  2.26114035e-01\n  9.95179892e-01  4.55000669e-01  4.56752568e-01  2.68411219e-01]\nSince a table cannot be part of the Primary HDU, we create an empty Primary HDU and use it with the table HDU to create a FITS file.>>> phdu = pyfits.PrimaryHDU()\n>>> print phdu.header\nSIMPLE =          T / conforms to FITS standard\nBITPIX =          8 / array data type\nNAXIS  =          0 / number of array dimensions\nEXTEND =          T\n>>> table_hdu.name = \"MyTab\" # EXTNAME header keyword\n>>> print table_hdu.header\nXTENSION= 'BINTABLE'      / binary table extension\nBITPIX =          8 / array data type\nNAXIS  =          2 / number of array dimensions\nNAXIS1 =         4014 / length of dimension 1\nNAXIS2 =          10 / length of dimension 2\nPCOUNT =          0 / number of group parameters\nGCOUNT =          1 / number of groups\nTFIELDS =          3 / number of table fields\nTTYPE1 = 'target '\nTFORM1 = '10A   '\nTTYPE2 = 'counts '\nTFORM2 = 'J    '\nTTYPE3 = 'spectrum'\nTFORM3 = '1000E  '\nEXTNAME = 'MYTAB  '      / extension name\n>>> hdulist = pyfits.HDUList([phdu, table_hdu])\n>>> hdulist.info()\nFilename: (No file associated with this HDUList)\nNo.  Name     Type   Cards  Dimensions  Format\n0  PRIMARY   PrimaryHDU    4 ()\n1  MYTAB    BinTableHDU   15 10R x 3C   ['10A', 'J', '1000E']\n>>> hdulist.writeto('table.fits')\n>>> pyfits.info('table.fits')\nFilename: table.fits\nNo.  Name     Type   Cards  Dimensions  Format\n0  PRIMARY   PrimaryHDU    4 ()      uint8\n1  MYTAB    BinTableHDU   15 4R x 3C    [10A, J, 1000E]\nSection 5.2, in page 26, of the\u00a0PyFITS Handbook\u00a0describes ways to append columns to a table and merge two tables.Finallyhttp://twitter.com/#!/doug_burke/status/2375100477214720", "tags": ["PyFITS", "FITS"], "title": "PyFITS: FITS files in python - part 2"}