{"date_published": "2010-01-20", "author": "virtualastronomer", "description": "For this tutorial I will assume user installation of new packages by building from downloaded source, ie \"python setup.py install.\" While this tutorial also applies to user installations with the easy_install command line tool, I reserve easy_install related notes to the \"Gotcha's\" section at the end of this tutorial.This tutorial also assumes the reader is a user rather than a developer of python packages and need not worry about multiple or virtual python installations in day to day use. Of course updating to a different version [2.4,2.5,2.6,...] of python requires the user to rebuild their user library.A word on python versions: Common python versions include 2.4 (what is on the system administered Linux computers where I work), 2.5 on Mac OS X 10.5 and 2.6 on Mac OS X 10.6. What is below is based on the official 2.6 docs, and the example uses syntax appropriate for version 2.4. It will work for all three versions. A new feature added in python 2.6 that would provide alternatives to this technique is discussed briefly in the \"Gotchas\" section.GistA user configuration file, ~/.pydistutils.cfg, will override the internal system path for python package installations, redirecting the built libraries (lib), scripts (bin) and data (share) into user owned and specified directories. You must simply tell the python installer where theses directories are located.The user file, ~/.pydistutils.cfg, has the following lines, using a pretty obvious syntax:[install]install_scripts = ~/usr/bininstall_data = ~/usr/shareinstall_lib = ~/usr/lib/python2.4/site-packagesThis example assumes you will simply create an alternate \"usr\" tree in your home (~) directory, mimicking the UNIX /usr directory. There is nothing special about the names used for these directory paths, however. Generally, these user directories need not exist to specify them in ~/.pydistutils.cfg but to be safe one could simply run:mkdir -p ~/usr/binmkdir -p ~/usr/sharemkdir -p ~/usr/lib/python2.4/site-packagesThe location of your user Python library directory (install_lib) must be in your Python path (\"import sys; print sys.path\") prior to using the new modules OR installing new modules that have dependencies on other user installed modules. This requirement can be accomplished by explicitly adding the library directory to your python path. For the example above you would do this:in bash:export PYTHONPATH=~/usr/lib/python2.4/site-packages:${PYTHONPATH}or csh:setenv PYTHONPATH ~/usr/lib/python2.4/site-packages:${PYTHONPATH}where PYTHONPATH is ordered such that earlier entries supersede latter ones and the entire $PYTHONPATH supercedes all system libraries (but see Gotcha's).That is the gist of the solution.Example with this configurationWith this file in place builds using syntax such as:wget http://pypi.python.org/packages/source/T/TinyUrl/TinyUrl-0.1.0.tar.bz2#md5=a0b6a52ad898a35ea6280b43eb5c1be1tar xjvf TinyUrl-0.1.0.tar.bz2cd TinyUrl-0.1.0/python setup.py installwill build a command line tool, ~/usr/bin/tinyurl where I can now run:tinyurl http://www.astropython.org/tutorial/2010/1/User-rootsudo-free-installation-of-Python-modulesto yieldhttp://tinyurl.com/yhassawMore detailsTo use the scripts one might want to add the install_bin directory to your unix path, $PATH.\u00a0 Else one would need to explicitly call the above example as ~/usr/bin/tinyurl ..., instead.Gotchas1. Regarding default user writable installation directories: Mac In some cases the current system python knows to check for a default user writable directory for modules in user installed packages without resorting to the $PYTHONPATH variable.\u00a0 This is the case for Mac OS X (Leopard), where the directory:~/Library/Python/2.5/site-packagesis automatically searched for modules to add to the python path (whether you knew that or not might be another point of value for this tutorial!). You would instead substitute that directory,install_lib = ~/Library/Python/2.5/site-packagesin ~/.pydistutils.cfg.\u00a0\u00a0 The gotcha for this is that this directory is searched *last* on the system python module path and as such the user may not be able to override system installed packages using this particular default directory. You cannot override this path ordering by adding it to your $PYTHONPATH because it is interpreted as a duplicate path and ignored. 2. easy_installThe easy_install command line tool will respect the installation instructions provided in ~/.pydistutils.cfg, however, there are gotchas related to how easy_install manipulates the module path that should be mentioned. The most critical issue with easy_install and user installed python packages is the fact that packages can be installed in different ways that cause their modules to have priorities that appear to differ from the formal system path.\u00a0 The way the python module path works, $PYTHONPATH should override all other directories (this is built into the basic architecture).\u00a0\u00a0 The standard path ordering would be this:\nPYTHONPATH \u00a0\nSystem owned site-directories (e.g., /usr/local/python2.4/site-packages)\n~/Library/Python/2.X/site-packages [on Macs]\n\nConsider the case of \"numpy,\" the widely used numeric library in python.\u00a0\u00a0 Lets suppose your system (root) installation includes numpy 1.3 installed in a system site directory:cd ~python -c \"import numpy; print numpy.__version__,numpy.__file__\" # 1.3# /usr/local/lib/python2.4/site-packages/numpy/__init__.pyYou then install the release version of numpy (1.4) with easy_install and ~/.pydistutils.cfg with install_lib =\u00a0 ~/usr/lib/python2.4/site-packages:easy_install -ZU numpypython -c \"import numpy; print numpy.__version__,numpy.__file__\" # 1.4# ~/usr/local/lib/python2.4/site-packages/numpy-1.4.0-py2.4-linux-x86_64.egg/numpy/__init__.pyNow you need some bleeding edge feature. So you download the source for the developer version of numpy via svn (1.5.svn) and run with the same ~/.pydistutils.cfg file:svn co http://svn.scipy.org/svn/numpy/trunk numpycd numpy python setup.py installcd ~python -c \"import numpy; print numpy.__version__,numpy.__file__\" # 1.4# ~/usr/local/lib/python2.4/site-packages/numpy-1.4.0-py2.4-linux-x86_64.egg/numpy/__init__.pyThis is not intuitive unless you understand that while easy_install follows the same path ordering process, it builds its packages (called \"eggs\") and pre-pends them to the other paths. The module path now looks like:\neasy_install to $PYTHONPATH\neasy_install to System owned site-directories\neasy_install to ~/Library/Python/2.X/site-packages [on Macs]\n$PYTHONPATH \u00a0\nSystem owned site-directories \n~/Library/Python/2.X/site-packages [on Macs]\n\nAnd your numpy installations are thus ordered:\nnumpy 1.4 (w/easy_install)\nnumpy 1.5 svn (with python setup.py install to $PYTHONPATH location)\nnumpy 1.3 system\n\non the python module path.\u00a0 Moreover, if your system installation of numpy was built with easy_install your 1.5svn attempt falls to third place above. As such if your system owned installation used easy_install to install packages then you are basically forced to also use easy_install because the system easy_install'ed packages will supersede even your $PYTHONPATH unless you also install with easy_install. This is not to discount easy_install. I always use it.\u00a0 If you or your root install have used it, just keep always using it. For example, the way I do this with the numpy 1.5 svn versions is:svn co http://svn.scipy.org/svn/numpy/trunk numpycd numpy python setup.py buildcd ..easy_install -ZU ./numpycd ~python -c \"import numpy; print numpy.__version__,numpy.__file__\" # 1.5.0.dev8079 # ~/usr/local/lib/python2.4/dist-packages/numpy-1.5.0.dev8079-py2.4-linux-x86_64.egg/numpy/__init__.pyUsing easy_install, also makes it straightforward for me to switch versions of numpy that I have already installed.\u00a0 For the working example, I have an easy_installed numpy 1.4 and numpy 1.5.0.dev8079. To switch I simply run easy_install and point at the requested version:~/usr/bin/easy_install -Z numpy==1.5.0.dev8082 ; python -c 'import numpy; print numpy.__version__'# 1.5.0.dev8079~/usr/bin/easy_install -Z numpy==1.4 ; python -c 'import numpy; print numpy.__version__'# 1.4.0Starting from scratch with easy_installAt my institution the system administered Linux workstations use python2.4 and lack easy_install and the ipython shell. In this case I set up my ~/.pydistutils.cfg according to the example at the beginning of the tutorial, created the three install directories, and ran:wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz#md5=7df2a529a074f613b509fb44feefe74etar xzvf setuptools-0.6c11.tar.gzpython setup.py installwhich installed easy_install into ~/usr/bin.\u00a0 Then, without problem, I then ran~/usr/bin/easy_install -Z nose~/usr/bin/easy_install -Z numpypython -c \"import numpy;numpy.test()\"~/usr/bin/easy_install -Z ipython==0.9.1~/usr/bin/easy_install -Z PIL~/usr/bin/easy_install -Z matplotlib3. Python 2.6+Python 2.6 adds a default tree for user directories that is searched before system libraries and without specifying it on the user $PYTHONPATH.\u00a0 This predefined tree is rooted at \"~/.local\" in unix environs, where user installed packages are added in \"~/.local/lib/python2.6/site-packages\" and executable scripts in ~/.local/bin.\u00a0 You can use this directory without ~/.pydistutils.cfg by compiling source packages with: python setup.py install --userNote that an entry in ~/.pydistutils.cfg file, such as install_lib = ~/usr/lib/python2.6/site-packageswill override the --user option, redirecting modules to install_lib. In this specific case \"~/usr/lib/python2.6/site-packages\" will not be automatically searched for modules unless it is added to $PYTHONPATH.\u00a0 Further, the search path now looks like:\n$PYTHONPATH\u00a0 \n~/.local/lib/python2.6/site-packages\nSystem owned site-directories (e.g., /usr/local/python2.4/site-packages)\n~/Library/Python/2.X/site-packages [on Macs]\n\nFinally, to easy_install with Python 2.6's $PYTHONPATH free installation of user installed packages in \".local,\" users would type:easy_install --prefix=~/.local -ZU tinyurlfor the original installation example above.\u00a0 The binary is now in ./local/bin/tinyurl and the module search path with easy_install packages is now:\neasy_install to $PYTHONPATH\neasy_install to ~/.local/lib/python2.6/site-packages\neasy_install to System owned site-directories\neasy_install to ~/Library/Python/2.X/site-packages [on Macs]\n$PYTHONPATH\u00a0 \n~/.local/lib/python2.6/site-packages\nSystem owned site-directories \n~/Library/Python/2.X/site-packages [on Macs]", "tags": ["module", "packages", "environment"], "title": "User (root/sudo free) installation of Python modules."}