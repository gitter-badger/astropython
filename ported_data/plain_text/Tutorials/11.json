{"date_published": "2010-10-24", "author": "phn", "description": "PyFITS: FITS files in PythonIn this article, we provide examples of using the python module\u00a0PyFITS\u00a0for working with FITS data. We first go through a brief overview of the FITS standard, and then we describe ways for accessing information in FITS files, using convenience functions defined in PyFITS. PyFITS offers facilities that provide more advanced access to information in FITS files, but these will not be discussed here. Perhaps, a future article will discuss these.These instructions are based on the\u00a0PyFITS Handbook\u00a0(link is to a PDF file), which has exhaustive information on the facilties provided by PyFITS.ContentsBrief overview of the FITS standard\nAccesing FITS files with PyFITS\nGetting basic information on a FITS file\nGetting information from headers of FITS files\nGetting data from FITS files\nCreating and modifying FITS files\n\nFITS header keywords\nLinks\n\nBrief overview of the FITS standardFITS stands for\u00a0Flexibile Image Transport System, and is the IAU recognized standard for storing astronomical data.A FITS file consists of one or more\u00a0header and data units, referred to as\u00a0HDUs. An HDU consists of a header, which describes the data contained in the HDU, followed by the data itself. The first HDU is called the\u00a0Primary HDU. Other HDUs, if present, are referred to as\u00a0extensions.In a valid FITS file the data part of an HDU can be empty. The simplest valid FITS file is one with just the header of the Primary HDU. A FITS file with only the Primary HDU is refered to as a\u00a0Basic FITS\u00a0file or a\u00a0Single Image FITS (SIF)\u00a0file. A FITS file with extensions is referred to as a\u00a0Multi-Extension FITS (MEF)\u00a0file.A header consists of\u00a0records, also called\u00a0card images, each having a maximum of 80 characters. A record contains a\u00a0keyword\u00a0with maximum length of 8 characters, an \"=\" sign at the 9th position, a space at the 10th position, followed by a value for the keyword. A \"/\" after the value of the keyword indicates the beginning of a\u00a0commentfor the record and the characters from that point, through the 80th character becomes the comment. The only characters allowed in a header record are ASCII values 32 to 126. A record can be a blank record in which case the entire record will be filled with ASCII space character (ASCII 32). The special keywords\u00a0HISTORY\u00a0andCOMMENT, do not use \"=\" sign and simply uses positions 11 to 80, to store the value.There is a set of standard keywords, some mandatory and others optional, defined in the FITS standard. Document describing the standard is available from\u00a0the FITS Support Office. In addition to these there are many non-standard FITS keywords that are used quite frequently. The exact keywords included in an header depends on the type of the data in the data part of the HDU. A list of standard and, non-standard but frequently used, keywords is available athttp://fits.gsfc.nasa.gov/fits_dictionary.html. In addition, \"World Coordinate System\" (WCS) information is stored in keywords defined in appropriate standards, which are also linked to at the above url.The value of a header keyword can be of the following types.String; ascii characters enclosed in single quotes.\nLogical; letter T or letter F.\nIntegers; signed decimal numbers.\nFloating point numbers; similar to integers, with E or D denoting the exponent part.\nComplex numbers; specified as (real, imag).\n\nThe data in an HDU can be an\u00a0image, which is an array of dimensions 1 to 999, a\u00a0binary table\u00a0or an\u00a0ASCII table. There is another type of data structure called random groups, which is used only in radio interferometry work.Data can be 8-bit characters, integers (8-bit unsigned, and 16-bit, 32-bit and 64-bit signed integers) and floating point numbers (32-bit and 64-bit). The data type is indicated using the\u00a0BITPIX\u00a0keyword, with value set to the number of bits, e.g., 8 for characters and unsigned integers. The values -32 and -64 are used for 32-bit and 64-bit formats, respectively.An important thing to keep in mind is that the value stored in a data array, the raw value, need not be the actual value representing the physical quantity. If this is so, then the keywords\u00a0BSCALE\u00a0and\u00a0BZERO\u00a0will have values other than 1.0 and 0.0, respectively. The actual quantity that is being conveyed can be calculated asphysical_value = raw_value * BSCALE + BZERO.\nNotePyFITS will automatically perform this conversion, when it reads in data from a FITS file. The BITPIX value will also be changed to reflect this.For tables, the corresponding keywords are\u00a0TSCALEn\u00a0and\u00a0TZEROn, where \"n\" denotes the field, i.e., table column, for which this value is applicable. So we have,\u00a01 <= n <= TFIELDS, where\u00a0TFIELDS\u00a0is the number of columns in the table.The number of \"dimensions\" for data arrays is specified using the keyword\u00a0NAXIS. The length of each dimension is specified using the keyword\u00a0NAXISn\u00a0where\u00a01 <= n <= NAXIS.Consider a \"data cube\" with 200 rows (y-axis), 200 columns (x-axis) and 4 \"pages\" (z-axis). Then NAXIS = 3, NAXIS1 = 200 (x-axis), NAXIS2 = 200 (y-axis) and NAXIS3 = 4 (z-axis). The data is stored in \"row-major\" format so that, we would access an element in row 10, col 8 and page 1 as\u00a0data[0][9][8]\u00a0in C, and asdata[0][9][8]\u00a0or\u00a0data[0,9,8]\u00a0in Python.Tables can only appear in extensions and not in Primary HDU and the type of the table will be indicated in the\u00a0XTENSION\u00a0keyword of the header of the concerned HDU. If an extension contains image data, i.e., an array, then XTENSION = IMAGE.For an ASCII table, i.e., XTENSION = TABLE, NAXIS will always be 2. NAXIS1 will be the total number of 8-bit characters in a row, and NAXIS2 will be the number of rows. In FITS a \"column\" is a position in a row, where as a \"field\" represents a column in the table. The number of columns in a table, is therefore, given by the value of the keyword TFIELDS.Binary tables, i.e., XTENSION = BINTABLE, have the same interpretation for NAXIS and NAXIS2. In ASCII tables a value in a particular \"cell\" will be a scalar. But in a binary table this can be a vector. The value of NAXIS1 for a binary table will take this into account.Accesing FITS files with PyFITSPyFITS provides several \"convenience\" functions that allow the user to work with FITS data, without having to deal with opening and closing files. As mentioned before, there are methods available that provide much finer control over accessing FITS data.In the following examples, we use the FITS file \"WFPC2u5780205r_c0fx.fits\", which is linked to by the first link in the table athttp://fits.gsfc.nasa.gov/fits_samples.html.In the code samples below, lines beginning with \">>>\" are code entered into the python shell. Only part of long outputs are shown and these are indicated with the string \"...\".Getting basic information on a FITS file>>> import pyfits\n>>> pyfits.info(\"WFPC2u5780205r_c0fx.fits\")\nFilename: WFPC2u5780205r_c0fx.fits\nNo.  Name     Type   Cards  Dimensions  Format\n0  PRIMARY   PrimaryHDU   262 (200, 200, 4) float32\n1  U5780205R_CVT.C0H.TAB TableHDU    353 4R x 49C   [D25.17,\nD25.17, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7,\nA1, E15.7, I12, I12, D25.17, D25.17, A8, A8, I12, E15.7, E15.7,\nE15.7, E15.7, E15.7, E15.7, I12, I12, I12, I12, I12, I12, I12,\nI12, A48, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7,\nE15.7, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7, E15.7]\nThe output shows that the file has two HDUs. The header of the Primary HDU has 262 header records and the data part is a 4x200x200 array, i.e., 4 \"pages\", 200 rows and 200 columns, of 32 bit floating point numbers. The file has a table extension which has a header of 353 records and the data part has 4 rows and 49 columns. The data format in each column is also given. The total number of 8-bit bytes in one row is 747+49, i.e., 747 bytes indicated by the format strings and one 8-bit separator associated with each column.Note that while using PyFITS we often refer to the Primary HDU as extension number 0 and the first FITS extension as extension number 1.Getting information from headers of FITS filesThe\u00a0getheader\u00a0function returns the header of a specified extension. If no extension is given then the header of the Primary HDU is returned.>>> header_primary = pyfits.getheader(\"WFPC2u5780205r_c0fx.fits\")\nThe header can be treated as a python dictionary. So to find all keywords in the header we can execute>>> header.keys()\n['SIMPLE',\n 'BITPIX',\n 'NAXIS',\n 'NAXIS1',\n 'NAXIS2',\n 'NAXIS3',\n 'EXTEND',\n 'COMMENT',\n 'BSCALE',\n ...\nThe keys can be used to access information in the header. Note that the keys are case-insensitive.>>> header['BITPIX']\n-32\n>>> header['bitpix']\n-32\n>>> header['naxis']\n3\n>>> header['naxis1']\n200\n>>> header['naxis2']\n200\n>>> header['naxis3]\n4\nTo get the header of the first extension we can give a number, indicating the extension, to the\u00a0getheader\u00a0function. Here, since the table is the first extension we give the number 1. To get the primary header we can either omit the number or give the number 0.>>> header_table = pyfits.getheader(\"WFPC2u5780205r_c0fx.fits\",1)\n>>> header_table.keys()\n['XTENSION',\n 'BITPIX',\n 'NAXIS',\n 'NAXIS1',\n 'NAXIS2',\n 'PCOUNT',\n 'GCOUNT',\n 'TFIELDS',\n 'EXTNAME',\n ...\n>>> header_table['naxis']\n2\n>>> header_table['tfields'] # A field is a table column.\n49\n>>> header_table['naxis2']\n4\n>>> header_table['naxis1']\n796\nIf we know that a header has a keyword, and we just want to find its value, we can use the\u00a0getval\u00a0function.>>> pyfits.getval('WFPC2u5780205r_c0fx.fits','bitpix',0)\n-32\n>>> pyfits.getval('WFPC2u5780205r_c0fx.fits','bitpix',1)\n8\n>>> pyfits.getval('WFPC2u5780205r_c0fx.fits','xtension',1)\n'TABLE'\nThe last line of the output shows that the table in the FITS file is an ASCII table. A binary table will have the value 'BINTABLE' and an image array will have the value 'IMAGE'.To see the comment associated with a keyword, we will need to access the list of\u00a0Card Object\u00a0in the header.>>> header1_cards = header1.ascardlist()\n>>> print header1_cards['bitpix']\nBITPIX =          8 / Data typex\nGetting data from FITS filesTo get the data part from an HDU we use the\u00a0getdata\u00a0function, passing it the name of the FITS file and the HDU from which data needs to be obtained.>>> data_cube = pyfits.getdata('WFPC2u5780205r_c0fx.fits\",0)\nTo get header along with data set the\u00a0header\u00a0option to\u00a0True.>>> data_cube, header_data_cube = pyfits.getdata(\n  'WFPC2u5780205r_c0fx.fits', 0, header=True)\nIf data in the HDU is an image, then the data returned is a\u00a0numpy ndarray object\u00a0.>>> type(data_cube)\n<type 'numpy.ndarray'>\n>>> data_cube.shape\n(4, 200, 200)\nThe shape parameter returns the shape of the array as a tuple of the format (NAXIS3, NAXIS2, NAXIS1) or in general (NAXISn, ..., NAXIS1), where n is the value of the keyword NAXIS. This means that NAXIS1 is the number of\u00a0columns\u00a0(x axis), NAXIS2 is the number of\u00a0rows\u00a0(y axis) and NAXIS3 is the number of\u00a0pages\u00a0(z-axes).The following illustrates that the \"data cube\" behaves just like a regular array. Here,\u00a0numdisplay\u00a0is used to display the array on\u00a0DS9. DS9 should be running before calling\u00a0numdisplay.display.>>> import copy\n>>> data_cube_copy = copy.deepcopy(data_cube)\n>>> data_cube_copy_page_3 = data_cube_copy[3]\n>>> import numdisplay\n>>> numdisplay.display(data_cube[3])\nImage displayed with Z1: -4.29414 Z2: 813.35\n>>> data_cube_copy_page_3[90:110,:] = 32000.0\n>>> numdisplay.display(data_cube_copy_page_3)\nImage displayed with Z1: -4.29414 Z2: 32000.0\n>>> data_cube_copy_page_3[:,20:30] = 32000.0\n>>> numdisplay.display(data_cube_copy_page_3)\nImage displayed with Z1: -4.29414 Z2: 32000.0\n>>> data_cube_copy_page_3[:,-30:-20] = 32000.0\n>>> numdisplay.display(data_cube_copy_page_3)\nImage displayed with Z1: -4.29414 Z2: 32000.0\nIf data in the HDU is a table then an object similar to a\u00a0numpy record array\u00a0is returned. As mentioned before, in FITS, what we call a \"table column\" is referred to as a \"field\". A \"column\" in FITS referes to an 8-bit byte in a row, i.e., a position in a row. Hence a \"field\" will span a range of \"columns\".>>> data_table, header_table =\n  pyfits.getdata(\"WFPC2u5780205r_c0fx.fits\", 1, header=True)\n>>> type(data_table)\n<class 'pyfits.core.FITS_rec'>\n>>> data_table[0] # First row\n...\n>>> data_table[0][0] # First row, first column\n182.63118863080001\n>>> data_table.field(0) # first column\narray([ 182.63118863, 182.62552336, 182.65237923, 182.65002236])\n>>> data_table.names # Names of individual columns\n...\n>>> len(data_table.names) # Should be 49, since there are 49 columns\n49\n>>> data_table.field('crval1') # Data in column named CRVAL1\narray([ 182.63118863, 182.62552336, 182.65237923, 182.65002236])\n>>> b = data_table.field('backgrnd')\n>>> b[0] # first row in the column 'backgrnd'\n-0.36763531\nCreating and modifying FITS filesKeys can be easily added to and removed from headers, using the methods provided by the \"header object\".>>> del header_table['bitpix']\n>>> header_table.has_key('bitpix')\nFalse\n>>> header_table.update('bitpix', 8, comment=\"Data type in bits.\")\n>>> header_table['bitpix']\n8\nTo add a key use the\u00a0update\u00a0method of the header. This method will add a keyword if that is not present, and will modify the value of the keyword if it is present.>>> header_table.has_key('avg1')\nFalse\n>>> header_table.update('AVG1', 23.0, \"Avg in BOX1\")\n>>> header_table['avg1']\n23.0\n>>> header_table.ascardlist()['avg1']\nAVG1  =         23.0 / Average in BOX1\nThe methods,\u00a0add_comment,\u00a0add_history\u00a0and\u00a0add_blank\u00a0can be used to insert COMMENT, HISTORY and blank keywords, while the\u00a0get_comment\u00a0andget_history\u00a0methods will retrieve a list of COMMENT and HISTORY keywords in the header. One can use the syntax\u00a0header['COMMENT']\u00a0to get the value of a comment, but since a FITS header can contain more than 1 COMMENT and HISTORY keywords, this will only return the first such keyword. The methods to add the above keywords also allow one to specify where the keywords must be inserted.The code>>> header_table.add_comment(\"A new comment\", before=\"median\")\nwill insert a COMMENT key, just before the key MEDIAN. There is a keyword parameter,\u00a0after, to do the insertion after a specified keyword.To create a new FITS file with some data and header information we can use the\u00a0writeto\u00a0function, providing it with a\u00a0filename, some\u00a0data\u00a0and a\u00a0header.>>> pyfits.writeto(filename, data, header)\nExample:>>> pyfits.writeto(\"WFPC_copy_page_3.fits\", data_copy_page_3)\nSince a\u00a0header\u00a0was not provided, a minimal header will be inserted into the file.The function\u00a0append\u00a0can be used to append an HDU to an already existing FITS file.>>> pyfits.append(filename, data, header)\nThe\u00a0data\u00a0and\u00a0header\u00a0provided will be appended as an HDU extension to the FITS file represented by\u00a0filename.Note that in both\u00a0writeto\u00a0and\u00a0append\u00a0functions, the\u00a0header\u00a0is optional. If not given a minimal header will be inserted into the HDU extension.The function\u00a0update\u00a0is used to update an HDU.>>> pyfits.update(filename, data, header, extension)\nExamples:\nUpdate extension number 3 with provided data and header>>> pyfits.update(filename, data, header, ext=3)\n\nUpdate extension 3 with data but do not change the header>>> pyfits.update(filename, data, ext=3)\n\nUpdate the extension named 'sci'>>> pyfits.update(filename, data, ext='sci')\n\n\nFITS header keywordsTHe following are some of the important keywords defined in the FITS standard.KeywordDescriptionSIMPLESet to T if the file conforms to the FITS standard and to F if not.BITPIXDatatype of the data in the HDU.XTENSIONType of extension: IMAGE, TABLE, BINTABLE.NAXISNumber of dimensions of a data array. For tables this is always 2.NAXISnLength of each dimension. Here 1 <= n <= NAXIS. For tables NAXIS1 is the number of table rows.TFIELDSNumber of fields, i.e., table columns, in the table.TFORMnFormat of data in the nth table column. See table 7.3 in page 50 of the FITS Standard.BSCALEFactor by which data in an image has been scaled.BZEROZero point of the data in an image array.TSCALEnSame as BSCALE, but for table column n.TZEROnSame as BZERO, but for table column n.Links\nPyFITSPython module for working with FITS data.\nNASA/GSFC\u00a0FITS Support OfficeAuthoritative information on the FITS format, including documentation and links to software for manipulating FITS files.\n\n\nNumpyBasic python package for scientific computing, including facilities for the creation and manipulation of N-dimensional arrays.\n\nNumdisplay\n\nPython module for interacting with image display softwares, such as\u00a0DS9.", "tags": ["PyFITS", "FITS"], "title": "PyFITS: FITS files in Python"}