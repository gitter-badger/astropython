{"date_published": "2013-07-14", "author": "aldcroft", "description": "<div class=\"entry\" id=\"blogbody\">\n<p><strong>This guest post was contributed by Moritz Guenther:</strong></p><p>When I first encountered the IPython notebook, I thought this was a solution looking for a problem. However, I have since been converted! The tipping point for me was this: I want to version control my papers and I always had multiple directories for analysis code, plotting code, LaTeX files, plot scripts and figures and tables. That's just so unwieldy. Also, I found it cumbersome to email figures to individual collaborators all the time. The Notebook can hold all this information in one place and I can just provide my co-authors with a link to the github repository once and they have access to the latest version all the time. Even if they do not use python, they can still see the all the current figures using <a href=\"http://nbviewer.ipython.org\" target=\"_blank\">nbviewer.ipython.org</a><br/><br/>Now all papers I work on a are written in an IPython notebook. So, the final step to do is to convert the notebook to the LaTeX file I can submit to a journal. That's what this simple converter code does.<br/><br/>This converter is not intended to replace nbconvert from the IPython project. Instead, it serves one very specific purpose: Turn a notebook into a LaTeX file that I can submit to the journal.<br/></p><h1>How to use it</h1><h2>As a script<br/></h2><br/>You can use this file form the command line:<p></p><pre class=\"python\" name=\"code\">&gt; python ipynb2article.py myanalysis.ipynb myanalysis.tex</pre><p>In this case it's run with my set of design choices (see below).<br/></p><h2>As a Python module</h2>Import into python and make a &lt;tt&gt;NotebookConverter&lt;/tt&gt; object:<p></p><pre class=\"python\" name=\"code\">from ipynb2article import NotebookConverter\nconverter = NotebookConverter\n</pre><p>Then, customize how each type of cell is converted by changing the converter:</p><pre class=\"python\" name=\"code\">converter.cellconverters['code'] = NotebookConverter.IgnoreConverter()\n</pre><p>Finally, call:</p><pre class=\"python\" name=\"code\">converter.convert(infile, outfile, ...)\n</pre><p>This method allows you to use only part of a notebook file (ignore to first n cells or ignore everything until a cell has a specific string value, e.g. \"The paper starts here\"). Also, it allows you to provide a text file that will be pasted before or after the converted notebook (you can put the 'usepackage' and similar stuff in those files so they don't clutter your notebook). However, I do not use this option any longer, because that means I would have multiple input files. If I put all those LaTeX headers into the notebook as well, I only have a single file.<br/></p><h1>Design</h1>The code is written around these design ideas:<p></p><ul>\n<li>Be able to ignore certain parts of the notebook (e.g. introductory comments in the first few cells).</li>\n<li>Convert headings to section / subsection etc. I generally use \"Heading 2\" for section, \"Heading 3\" for subsections etc. In the notebook, just press \"Ctrl+m 2\" to format a cell as \"Heading 2\" or select with the mouse from the drop-down menu.</li>\n<li>Copy text in \"markdown\" and \"raw text\" cells. To simplify, I just write real LaTeX code in those cells. All equations will be rendered correctly in the notebook file for me and my co-authors to see. When I want to highlight something I type LaTeX \"emph{}\" or \"textbf{}\", not the markdown equivalents. That looks not as nice in the notebook, but makes live so much easier. Also, markdown does not recognize \"cite\", \"ref\" and \"label\". Again, it looks not as nice in markdown, but (1) I only need to know LaTeX and (2) it works flawlessly when converted.</li>\n<li>No figure conversion. Instead, in the notebook itself I issue: f<em>ig.savefig('/path/to/my/article/XXX.eps') </em>because ApJ requires me to submit eps figures as separate files anyway.</li>\n<li>Just type figure captions into markdown cells.</li>\n<li>No conversion of code cells. Who wants code in an ApJ paper?</li>\n<li>Occasionally, I want to have the output of a computation (e.g. a table written with astropy in LaTeX format) in the article. Keep it simple. Output of all code cells that have a certain comment string (I use \"# output-&gt;LaTeX\") is copied verbatim to the LaTeX file.</li>\n<li>Work with the python standard library only. No external dependencies.</li>\n</ul>\n<p><br/>To implement this I wrote a converter for each cell type. <em>LiteralSourceConverter</em> just takes the literal string value (it also adds a line break at the end of the cell) and puts it into the LaTeX file (use for for markdown and raw text cells), <em>MarkedCodeOutputConverter</em> check if a code cell has a specific string in it and if so, it copies the output of this cell, and <em>LatexHeadingConverter</em> looks for the level of the heading and turns that into LaTeX (it also adds as label like \"label{sect:title}\").</p><p></p><h1>Code</h1><p></p><pre class=\"python\" name=\"code\"># Convert IPYthon notebook to LaTeX for ApJ or A&amp;A\nimport json\nimport re\n\nimport sys\nimport getopt\n\ndef isstartmarker(cell, start):\n if 'source' in cell.keys():\n  return cell['source'] == [start]\n elif 'input' in cell.keys():\n  return cell['input'] == [start]\n else:\n  raise ValueError('Type of cell not recognized.')\n\nclass IgnoreConverter(object):\n '''Use this converter for cell types that should be ignored'''\n def __call__(self, cell):\n  return []\n\nclass LiteralSourceConverter(object):\n '''This converter return the literal ``source`` entry of a cell.'''\n def __call__(self, cell):\n  text = cell['source']\n  text[-1] +='\\n'\n  return text\n\nclass MarkedCodeOutputConverter(object):\n '''Add output of code cells that have a specific string in the code cell'''\n def __init__(self, marker):\n  '''Add output of code cells that have a specific string in the code cell\n\n  Parameters\n  ----------\n  marker : string\n   Convert the output of a code cell if and only if one line in the\n   code matches ``marker``.\n   I often use ``marker='# output-&gt;LaTeX'`` to mark cells whose\n   output I want.\n  '''\n  self.marker = marker\n def __call__(self, cell):\n  text = []\n  if (self.marker in cell['input']) or (self.marker+'\\n' in cell['input']):\n   for out in cell['outputs']:\n    if 'text' in out:\n     text.extend(out['text'])\n     \n  if len(text) &gt; 0:\n   text[-1] +='\\n'\n  return text\n\nclass LatexHeadingConverter(object):\n '''Convert headings in notebook to appropriate level in LaTeX'''\n def __init__(self, latexlevels=['chapter','section','subsection', 'subsubsection', 'paragraph', 'subparagraph']):\n  '''Convert headings in notebook to appropriate level in LaTeX\n\n  Parameters\n  ----------\n  latexlevels : list of 6 strings\n   Latex equivalents for 'Heading 1', 'Heading 2' etc.\n  '''\n  self.latexlevels = latexlevels\n def __call__(self, cell):\n  # Just to be careful for multi-line headings\n  title = ''.join(cell['source']) \n  line1 = '\\\\{0}{{{1}}}\\n'.format(self.latexlevels[cell['level']-1],\n          title)\n  cleantitle = re.sub(r'\\W+', '', title)\n  line2 = '\\\\label{{sect:{0}}}\\n'.format(cleantitle.lower())\n  return ['\\n','\\n', line1, line2, '\\n']\n\nclass NotebookConverter(object):\n cellconverters = {\n      'code' : MarkedCodeOutputConverter('# output-&gt;LaTeX'),\n      'heading': LatexHeadingConverter(),\n      'markdown': LiteralSourceConverter(),\n      'raw': LiteralSourceConverter()\n      }\n def convert(self, infile, outfile, start = 0, file_before=None, file_after=None):\n  '''Convert IPython notebook to LaTeX file\n\n  Parameters\n  ----------\n  infile : string\n   filename of IPython notebook\n  outfile : string\n   filename of Latex file to be written\n  start : int or string\n   If this is a number, skip that many cells starting from the top;\n   if it is a string, skip cells until a cell has *exactly* the \n   content that ``start`` has.\n  file_before : string\n  file_after: string\n   String with filename. These files are copied above and below\n   the content from the ipynb file. Use this e.g. for templates\n   that contain the LaTeX header info that does not appear in the \n   notebook.\n  '''\n  with open(infile, 'r') as f:\n   print 'Parsing ', infile\n   ipynb = json.load(f)\n\n  cells = ipynb['worksheets'][0]['cells']\n  if isinstance(start, basestring):\n   while not isstartmarker(cells[0], start):\n    discard = cells.pop(0)\n   discard = cells.pop(0) # pop the marker cell\n  else:\n   for i in range(start):\n    discard = cells.pop(0)\n  \n  with open(outfile, 'w') as out:\n   print 'Writing ', outfile\n   if file_before is not None:\n    with open(file_before, 'r') as f:\n     for line in f:\n      out.write(line)\n   for cell in cells:\n    lines = self.cellconverters[cell['cell_type']](cell)\n    for line in lines:\n     out.write(line)\n   if file_after is not None:\n    with open(file_after, 'r') as f:\n     for line in f:\n      out.write(line)\n   \n  \nif __name__ == '__main__':\n converter = NotebookConverter()\n try:        \n  opts, args = getopt.getopt(sys.argv[1:], \"h\", [\"help\"])\n except getopt.GetoptError:   \n  print converter.convert.__doc__       \n  sys.exit(2)\n\n for opt, arg in opts:   \n  if opt in (\"-h\", \"--help\"): \n   print converter.convert.__doc__      \n   sys.exit()     \n \n print args\n converter.convert(*args)\n\n</pre><p></p><p></p>\n</div>", "tags": ["ipython", "notebook", "tutorial"], "title": "Convert IPython notebook to ApJ or A&A article"}