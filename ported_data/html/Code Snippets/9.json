{"date_published": "2010-11-20", "author": "aldcroft", "description": "<div class=\"entry\" id=\"blogbody\">\n<p>This code snippet shows a simple way to do linear or nearest-neighbor interpolation using only NumPy.\u00a0 This is handy if you don't have SciPy installed or don't want to introduce a dependency on SciPy in distributed code.\u00a0 By using the numpy.searchsorted() method and vectorized operations it is reasonably fast, though I have not made much effort to truly optimize the algorithm.</p><pre class=\"python\" name=\"code\">def interpolate(yin, xin, xout, method='linear'):\n  \"\"\"\n  Interpolate the curve defined by (xin, yin) at points xout. The array\n  xin must be monotonically increasing. The output has the same data type as\n  the input yin.\n\n  :param yin: y values of input curve\n  :param xin: x values of input curve\n  :param xout: x values of output interpolated curve\n  :param method: interpolation method ('linear' | 'nearest')\n\n  @:rtype: numpy array with interpolated curve\n  \"\"\"\n  lenxin = len(xin)\n\n  i1 = numpy.searchsorted(xin, xout)\n  i1[ i1==0 ] = 1\n  i1[ i1==lenxin ] = lenxin-1\n\n  x0 = xin[i1-1]\n  x1 = xin[i1]\n  y0 = yin[i1-1]\n  y1 = yin[i1]\n\n  if method == 'linear':\n    return (xout - x0) / (x1 - x0) * (y1 - y0) + y0\n  elif method == 'nearest':\n    return numpy.where(numpy.abs(xout - x0) &lt; numpy.abs(xout - x1), y0, y1)\n  else:\n    raise ValueError('Invalid interpolation method: %s' % method)# Python code here</pre><p></p>\n</div>", "tags": ["numpy"], "title": "Interpolation without SciPy"}