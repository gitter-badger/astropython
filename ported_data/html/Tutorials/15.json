{"date_published": "2010-01-20", "author": "virtualastronomer", "description": "<div class=\"entry\" id=\"blogbody\">\n            For this tutorial I will assume user installation of new packages by building from downloaded source, ie \"<em>python setup.py install</em>.\" While this tutorial also applies to user installations with the <em>easy_install</em> command line tool, I reserve <em>easy_install</em> related notes to the \"Gotcha's\" section at the end of this tutorial.<br/><br/>This tutorial also assumes the reader is a <strong>user</strong> rather than a developer of python packages and need not worry about multiple or virtual python installations in day to day use. Of course updating to a different version [2.4,2.5,2.6,...] of python requires the user to rebuild their user library.<br/><br/>A word on python versions: Common python versions include 2.4 (what is on the system administered Linux computers where I work), 2.5 on Mac OS X 10.5 and 2.6 on Mac OS X 10.6. What is below is based on the official 2.6 docs, and the example uses syntax appropriate for version 2.4. It will work for all three versions. A new feature added in python 2.6 that would provide alternatives to this technique is discussed briefly in the \"<strong>Gotchas</strong>\" section.<br/><br/><h3>Gist</h3>A user configuration file, <span style=\"color: #007f40;\">~/.pydistutils.cfg</span>, will override the internal system path for python package installations, redirecting the built libraries (lib), scripts (bin) and data (share) into user owned and specified directories. You must simply tell the python installer where theses directories are located.<br/><br/>The user file, <span style=\"color: #007f40;\">~/.pydistutils.cfg</span>, has the following lines, using a pretty obvious syntax:<br/><br/><br/><span style=\"color: #0000bf;\">[install]</span><br/><span style=\"color: #0000bf;\">install_scripts = ~/usr/bin</span><br/><span style=\"color: #0000bf;\">install_data = ~/usr/share</span><br/><span style=\"color: #0000bf;\">install_lib = ~/usr/lib/python2.4/site-packages</span><br/><br/><br/>This example assumes you will simply create an alternate \"usr\" tree in your home (~) directory, mimicking the UNIX <span style=\"color: #007f40;\">/usr</span> directory. There is nothing special about the names used for these directory paths, however. Generally, these user directories need not exist to specify them in <span style=\"color: #007f40;\">~/.pydistutils.cfg</span> but to be safe one could simply run:<br/><br/><br/><em><span style=\"color: #c00000;\">mkdir -p ~/usr/bin<br/>mkdir -p ~/usr/share<br/>mkdir -p ~/usr/lib/python2.4/site-packages</span><br/></em><br/><br/>The location of your user Python library directory (<span style=\"color: #0000bf;\">install_lib</span>) must be in your Python path (\"<em><span style=\"color: #c00000;\">import sys; print sys.path</span></em>\") prior to using the new modules OR installing new modules that have dependencies on other user installed modules. This requirement can be accomplished by explicitly adding the library directory to your python path. For the example above you would do this:<br/><br/><br/>in bash:<br/><br/><em><span style=\"color: #c00000;\">export PYTHONPATH=~/usr/lib/python2.4/site-packages:${PYTHONPATH}</span></em><br/><br/><br/>or csh:<br/><br/><em><span style=\"color: #c00000;\">setenv PYTHONPATH ~/usr/lib/python2.4/site-packages:${PYTHONPATH}</span></em><br/><br/><br/>where <strong>PYTHONPATH</strong> is ordered such that earlier entries supersede latter ones and the entire $<strong>PYTHONPATH</strong> supercedes all system libraries (but see Gotcha's).<br/><br/>That is the gist of the solution.<br/><br/><br/><h3>Example with this configuration</h3>With this file in place builds using syntax such as:<br/><br/><br/><em><span style=\"color: #c00000;\">wget <a style=\"font-family: yui-tmp;\">http://pypi.python.org/packages/source/T/TinyUrl/TinyUrl-0.1.0.tar.bz2#md5=a0b6a52ad898a35ea6280b43eb5c1be1</a></span><br/><br/><span style=\"color: #c00000;\">tar xjvf TinyUrl-0.1.0.tar.bz2</span><br/><br/><span style=\"color: #c00000;\">cd TinyUrl-0.1.0/</span><br/><br/><span style=\"color: #c00000;\">python setup.py install</span></em><br/><br/><br/>will build a command line tool, <span style=\"color: #407f00;\">~/usr/bin/tinyurl</span> where I can now run:<br/><em><br/><br/><span style=\"color: #c00000;\"><span style=\"color: #c00000;\">tinyurl http://www.astropython.org/tutorial/2010/1/User-rootsudo-free-installation-of-Python-modules</span></span></em><br/><br/><br/>to yield<br/><br/><br/><span style=\"color: #0000bf;\">http://tinyurl.com/yhassaw</span><br/><br/><br/><h3>More details</h3>To use the scripts one might want to add the install_bin directory to your unix path, $<strong>PATH</strong>.\u00a0 Else one would need to explicitly call the above example as <span style=\"color: #007f40;\">~/usr/bin/tinyurl</span> ..., instead.<br/><br/><br/><h3>Gotchas</h3><br/><h4><strong>1. Regarding default user writable installation directories: Mac</strong></h4> <br/>In some cases the current system python knows to check for a default user writable directory for modules in user installed packages without resorting to the $<strong>PYTHONPATH</strong> variable.\u00a0 This is the case for Mac OS X (Leopard), where the directory:<br/><br/><br/><span style=\"color: #007f40;\">~/Library/Python/2.5/site-packages</span><br/><br/><br/>is automatically searched for modules to add to the python path (whether you knew that or not might be another point of value for this tutorial!). You would instead substitute that directory,<br/><br/><br/><span style=\"color: #0000bf;\">install_lib = ~/Library/Python/2.5/site-packages</span><br/><br/><br/>in <span style=\"color: #007f40;\">~/.pydistutils.cfg</span>.\u00a0\u00a0 The <strong>gotcha</strong> for this is that this directory is searched *<strong>last</strong>* on the system python module path and as such the user may not be able to override system installed packages using this particular default directory. You cannot override this path ordering by adding it to your $<strong>PYTHONPATH</strong> because it is interpreted as a duplicate path and ignored. <br/><br/><br/><h4>2. <em>easy_install</em></h4><br/>The <em>easy_install</em> command line tool will respect the installation instructions provided in<span style=\"color: #007f40;\"> ~/.pydistutils.cfg</span>, however, there are gotchas related to how <em>easy_install</em> manipulates the module path that should be mentioned. <br/><br/>The most critical issue with <em>easy_install</em> and user installed python packages is the fact that packages can be installed in different ways that cause their modules to have priorities that appear to differ from the formal system path.\u00a0 The way the python module path works, $<strong>PYTHONPATH</strong> should override all other directories (this is built into the basic architecture).\u00a0\u00a0 The standard path ordering would be this:<br/><br/><br/><ol>\n<li><strong>PYTHONPATH</strong> \u00a0</li>\n<li>System owned site-directories (e.g., <span style=\"color: #007f40;\">/usr/local/python2.4/site-packages</span>)</li>\n<li><span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n</ol>\n<br/><br/>Consider the case of \"numpy,\" the widely used numeric library in python.\u00a0\u00a0 Lets suppose your system (root) installation includes numpy 1.3 installed in a system site directory:<br/><br/><br/><em><span style=\"color: #c00000;\">cd ~<br/>python -c \"import numpy; print numpy.__version__,numpy.__file__\" </span></em><br/><span style=\"color: #0000bf;\"># 1.3</span><br/><span style=\"color: #0000bf;\"># <span style=\"color: #007f40;\">/usr/local/lib/python2.4/site-packages/numpy/__init__.py</span></span><br/><br/><br/>You then install the release version of numpy (1.4) with <em>easy_install</em> and <span style=\"color: #007f40;\">~/.pydistutils.cfg</span> with <span style=\"color: #0000bf;\">install_lib =\u00a0 ~/usr/lib/python2.4/site-packages</span>:<br/><br/><br/><em><span style=\"color: #c00000;\">easy_install -ZU numpy<br/>python -c \"import numpy; print numpy.__version__,numpy.__file__\" </span></em><br/><span style=\"color: #0000bf;\"># 1.4</span><br/><span style=\"color: #0000bf;\"># <span style=\"color: #007f40;\">~/usr/local/lib/python2.4/site-packages/numpy-1.4.0-py2.4-linux-x86_64.egg/numpy/__init__.py</span></span><br/><br/><br/>Now you need some bleeding edge feature. So you download the source for the developer version of numpy via svn (1.5.svn) and run with the same <span style=\"color: #007f40;\">~/.pydistutils.cfg</span> file:<br/><br/><br/><em><span style=\"color: #c00000;\">svn co http://svn.scipy.org/svn/numpy/trunk numpy</span><br/><span style=\"color: #c00000;\">cd numpy </span><br/><span style=\"color: #c00000;\">python setup.py install</span><br/><span style=\"color: #c00000;\">cd ~</span><br/><span style=\"color: #c00000;\">python -c \"import numpy; print numpy.__version__,numpy.__file__\" </span></em><br/><span style=\"color: #0000bf;\"># 1.4</span><br/><span style=\"color: #0000bf;\"># <span style=\"color: #007f40;\">~/usr/local/lib/python2.4/site-packages/numpy-1.4.0-py2.4-linux-x86_64.egg/numpy/__init__.py</span></span><br/><br/><br/>This is not intuitive unless you understand that while easy_install follows the same path ordering process, it builds its packages (called \"eggs\") and pre-pends them to the other paths. The module path now looks like:<br/><br/><br/><ol>\n<li><em>easy_install</em> to $<strong>PYTHONPATH</strong></li>\n<li><em>easy_install</em> to System owned site-directories</li>\n<li><em>easy_install</em> to <span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n<li>$<strong>PYTHONPATH</strong> \u00a0</li>\n<li>System owned site-directories </li>\n<li><span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n</ol>\n<br/><br/>And your numpy installations are thus ordered:<br/><br/><br/><ol>\n<li>numpy 1.4 (w/<em>easy_install</em>)</li>\n<li>numpy 1.5 svn (with python setup.py install to $<strong>PYTHONPATH</strong> location)</li>\n<li>numpy 1.3 system</li>\n</ol>\n<br/>on the python module path.\u00a0 Moreover, if your <span style=\"text-decoration: underline;\">system</span> installation of numpy was built with <em>easy_install</em> your 1.5svn attempt falls to third place above. As such if your <span style=\"text-decoration: underline;\">system</span> owned installation used <em>easy_install</em> to install packages then you are basically forced to also use <em>easy_install</em> because the system <em>easy_install</em>'ed packages will supersede even your $<strong>PYTHONPATH</strong> unless you also install with <em>easy_install</em>. <br/><br/>This is not to discount <em>easy_install</em>. I always use it.\u00a0 If you or your root install have used it, just keep always using it. For example, the way I do this with the numpy 1.5 svn versions is:<br/><br/><br/><em><span style=\"color: #c00000;\">svn co <span>http://svn.scipy.org/svn/numpy/trunk</span> numpy</span><br/><span style=\"color: #c00000;\">cd numpy </span><br/><span style=\"color: #c00000;\">python setup.py build</span><br/><span style=\"color: #c00000;\">cd ..</span><br/><span style=\"color: #c00000;\">easy_install -ZU ./numpy</span><br/><span style=\"color: #c00000;\">cd ~</span><br/><span style=\"color: #c00000;\">python -c \"import numpy; print numpy.__version__,numpy.__file__\" </span></em><br/><span style=\"color: #0000bf;\"># 1.5.0.dev8079 </span><br/><span style=\"color: #0000bf;\"># <span style=\"color: #007f40;\">~/usr/local/lib/python2.4/dist-packages/numpy-1.5.0.dev8079-py2.4-linux-x86_64.egg/numpy/__init__.py</span></span><br/><br/><br/>Using <em>easy_install</em>, also makes it straightforward for me to switch versions of numpy that I have already installed.\u00a0 For the working example, I have an <em>easy_install</em>ed numpy 1.4 and numpy 1.5.0.dev8079. To switch I simply run <em>easy_instal</em>l and point at the requested version:<br/><br/><br/><em><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z numpy==1.5.0.dev8082 ; python -c 'import numpy; print numpy.__version__'</span></em><br/><span style=\"color: #0000bf;\"># 1.5.0.dev8079</span><br/><br/><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z numpy==1.4 ; python -c 'import numpy; print numpy.__version__'</span><br/><span style=\"color: #0000bf;\"># 1.4.0</span><br/><br/><br/><h4>Starting from scratch with easy_install</h4><br/>At my institution the system administered Linux workstations use <em>python2.4</em> and lack <em>easy_install</em> and the <em>ipython</em> shell. In this case I set up my <span style=\"color: #007f40;\">~/.pydistutils.cfg </span>according to the example at the beginning of the tutorial, created the three install directories, and ran:<br/><br/><br/><em><span style=\"color: #c00000;\">wget <a href=\"http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz#md5=7df2a529a074f613b509fb44feefe74e\" style=\"font-family: yui-tmp;\">http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz#md5=7df2a529a074f613b509fb44feefe74e</a></span><br/><br/><span style=\"color: #c00000;\">tar xzvf setuptools-0.6c11.tar.gz</span><br/><span style=\"color: #c00000;\">python setup.py install</span></em><br/><br/><br/>which installed <em>easy_install</em> into <span style=\"color: #007f40;\">~/usr/bin</span>.\u00a0 Then, without problem, I then ran<br/><br/><br/><em><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z nose</span><br/><br/><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z numpy</span><br/><br/><span style=\"color: #c00000;\">python -c \"import numpy;numpy.test()\"</span><br/><br/><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z ipython==0.9.1</span><br/><br/><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z PIL</span><br/><br/><span style=\"color: #c00000;\">~/usr/bin/easy_install -Z matplotlib</span></em><br/><br/><br/><h4>3. Python 2.6+</h4><br/>Python 2.6 adds a default tree for user directories that is searched before system libraries and without specifying it on the user $<strong>PYTHONPATH</strong>.\u00a0 This predefined tree is rooted at \"<span style=\"color: #007f40;\">~/.local</span>\" in unix environs, where user installed packages are added in \"<span style=\"color: #007f40;\">~/.local/lib/python2.6/site-packages</span>\" and executable scripts in <span style=\"color: #007f40;\">~/.local/bin</span>.\u00a0 You can use this directory without <span style=\"color: #007f40;\">~/.pydistutils.cfg</span> by compiling source packages with: <br/><br/><br/><em><span style=\"color: #c00000;\">python setup.py install --user</span></em><br/><br/><br/>Note that an entry in <span style=\"color: #007f40;\">~/.pydistutils.cfg</span> file, such as <span style=\"color: #0000bf;\"><br/><br/><br/>install_lib = ~/usr/lib/python2.6/site-packages</span><br/><br/><br/>will override the <em>--user </em>option, redirecting modules to install_lib. In this specific case \"<span style=\"color: #007f40;\">~/usr/lib/python2.6/site-packages</span>\" will not be automatically searched for modules unless it is added to $<strong>PYTHONPATH</strong>.\u00a0 Further, the search path now looks like:<br/><br/><br/><ol>\n<li>$<strong>PYTHONPATH</strong>\u00a0 </li>\n<li><span style=\"color: #007f40;\">~/.local/lib/python2.6/site-packages</span></li>\n<li>System owned site-directories (e.g., <span style=\"color: #007f40;\">/usr/local/python2.4/site-packages</span>)</li>\n<li><span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n</ol>\n<br/><br/>Finally, to <em>easy_install</em> with Python 2.6's $<strong>PYTHONPATH</strong> free installation of user installed packages in \"<span style=\"color: #007f40;\">.local</span>,\" users would type:<br/><br/><br/><em><span style=\"color: #c00000;\">easy_install --prefix=~/.local -ZU tinyurl</span></em><br/><br/><br/>for the original installation example above.\u00a0 The binary is now in <span style=\"color: #007f40;\">./local/bin/tinyurl</span> and the module search path with <em>easy_install</em> packages is now:<br/><br/><br/><ol>\n<li><em>easy_install</em> to $<strong>PYTHONPATH</strong></li>\n<li><em>easy_install</em> to <span style=\"color: #007f40;\">~/.local/lib/python2.6/site-packages</span></li>\n<li><em>easy_install</em> to System owned site-directories</li>\n<li><em>easy_install</em> to <span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n<li>$<strong>PYTHONPATH</strong>\u00a0 </li>\n<li><span style=\"color: #007f40;\">~/.local/lib/python2.6/site-packages</span></li>\n<li>System owned site-directories </li>\n<li><span style=\"color: #007f40;\">~/Library/Python/2.X/site-packages</span> [on Macs]</li>\n</ol>\n</div>", "tags": ["module", "packages", "environment"], "title": "User (root/sudo free) installation of Python modules."}