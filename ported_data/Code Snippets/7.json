{"code_in_html": "import numpy as np\nimport pywcs\nimport pyfits\nfrom numpy import sin, cos, radians\n\nDEBUG = False\n\ndef rotate(degs):\n \"\"\"Return a rotation matrix for counterclockwise rotation by ``deg`` degrees.\"\"\"\n rads = radians(degs)\n s = sin(rads)\n c = cos(rads)\n return np.array([[c, -s],\n  [s, c]])\n\ndef read_fits(name, hdu):\n \"\"\"Read FITS file ``name`` with an image in specified ``hdu`` number.\n Return the image HDU, list of all HDUs and the WCS object associated\n with the image HDU.\n \"\"\"\n hdulist = pyfits.open(name)\n img_hdu = hdulist[hdu]\n wcs = pywcs.WCS(img_hdu.header)\n return img_hdu, hdulist, wcs\n\ndef write_fits(hdulist, name, clobber=True, checksum=True):\n \"\"\"Write the ``hdulist`` to a FITS file with name ``name``.\"\"\"\n hdulist.writeto(name, clobber=clobber, checksum=checksum)\n\ndef update_header_wcs(hdu, wcs):\n \"\"\"Update the WCS CRVAL and CD values in the header for the given ``hdu``\n using the supplied ``wcs`` WCS object. This assumes that the CD values\n are being used instead of the PC values (as is the case for an HST\n Multidrizzle output). \n \"\"\"\n hdr = hdu.header\n hdr['CRVAL1'] = wcs.wcs.crval[0]\n hdr['CRVAL2'] = wcs.wcs.crval[1]\n if hasattr(wcs.wcs, 'cd'):\n hdr['CD1_1'] = wcs.wcs.cd[0,0]\n hdr['CD1_2'] = wcs.wcs.cd[0,1]\n hdr['CD2_1'] = wcs.wcs.cd[1,0]\n hdr['CD2_2'] = wcs.wcs.cd[1,1]\n if hasattr(wcs.wcs, 'pc'):\n hdr['PC1_1'] = wcs.wcs.pc[0,0]\n hdr['PC1_2'] = wcs.wcs.pc[0,1]\n hdr['PC2_1'] = wcs.wcs.pc[1,0]\n hdr['PC2_2'] = wcs.wcs.pc[1,1]\n\nclass WcsModel(object):\n def __init__(self, wcs, sky, pix0):\n self.wcs = wcs # Image WCS transformation object\n self.sky = sky # Reference (correct) source positions in RA, Dec\n self.pix0 = pix0.flatten() # Source pixel positions\n # Copy the original WCS CRVAL and CD values\n self.crval = wcs.wcs.crval.copy()\n if hasattr(wcs.wcs, 'cd'):\n self.cd = wcs.wcs.cd.copy()\n else:\n self.cd = wcs.wcs.pc.copy()\n\n def calc_pix(self, pars, x=None):\n \"\"\"For the given d_ra, d_dec, and d_theta pars, update the WCS\n transformation and calculate the new pixel coordinates for each\n reference source position.\n\n The \"x=None\" parameter is because Sherpa passes an extra \"X\"\n argument, which in this case we always ignore.\n \"\"\"\n d_ra, d_dec, d_theta = pars\n self.wcs.wcs.crval = self.crval + np.array([d_ra, d_dec]) / 3600.0\n if hasattr(self.wcs.wcs, 'cd'):\n self.wcs.wcs.cd = np.dot(rotate(d_theta), self.cd)\n else:\n self.wcs.wcs.pc = np.dot(rotate(d_theta), self.cd)\n pix = self.wcs.wcs_sky2pix(self.sky, 1)\n if DEBUG:\n print 'pix =', pix.flatten()\n print 'pix0 =', self.pix0.flatten()\n return pix.flatten()\n\n def calc_resid2(self, pars):\n \"\"\"Return the squared sum of the residual difference between the\n original pixel coordinates and the new pixel coords (given offset\n specified in ``pars``)\n\n This gets called by the scipy.optimize.fmin function.\n \"\"\"\n pix = self.calc_pix(pars)\n resid2 = np.sum((self.pix0 - pix)**2) # assumes uniform errors\n if DEBUG:\n print 'resid2 =', resid2\n return resid2\n\ndef match_wcs(wcs_img, sky_img, sky_ref, opt_alg='scipy'):\n \"\"\"Adjust ``wcs_img`` (CRVAL{1,2} and CD{1,2}_{1,2}) using a rotation and linear\n offset so that ``coords_img`` matches ``coords_ref``.\n\n :param sky_img: list of (world_x, world_y) [aka RA, Dec] coords in input image\n :param sky_ref: list of reference (world_x, world_y) coords to match\n :param wcs_img: pywcs WCS object for input image\n\n :returns: d_ra, d_dec, d_theta\n \"\"\"\n pix_img = wcs_img.wcs_sky2pix(sky_img, 1)\n wcsmodel = WcsModel(wcs_img, sky_ref, pix_img)\n y = np.array(pix_img).flatten()\n \n if opt_alg == 'sherpa':\n x = np.arange(len(y))\n import sherpa.astro.ui as ui\n ui.load_user_model(wcsmodel.calc_pix, 'wcsmod')\n ui.add_user_pars('wcsmod', ['d_ra', 'd_dec', 'd_theta'])\n wcsmod.d_ra = 0.0\n wcsmod.d_dec = 0.0\n wcsmod.d_theta = 0.0\n ui.load_arrays(1, x, y, np.ones(len(y)))\n ui.set_model(1, wcsmod)\n ui.set_method('simplex')\n ui.fit()\n else:\n import scipy.optimize\n x0 = np.array([0.0, 0.0, 0.0])\n d_ra, d_dec, d_theta = scipy.optimize.fmin(wcsmodel.calc_resid2, x0)\n print 'Scipy fit values:', d_ra, d_dec, d_theta\n\n return wcsmodel.wcs\n \ndef fix_img_wcs(infile, outfile, sky_ref, sky_img, opt_alg='scipy', hdu=1):\n \"\"\"\n Adjust the WCS transform in FITS file ``infile`` so that the sources\n positions given in ``sky_img`` most closely match the \"correct\" values in\n ``sky_ref``. The FITS image is assumed to be in the given ``hdu`` number\n (default=1). The updated image (along with any other HDUs) are written out\n to ``outfile``. The optimization algorithm can be \"scipy\"\n (scipy.optimize.fmin) or \"sherpa\".\n \"\"\"\n img_hdu, hdulist, wcs_img = read_fits(infile, hdu)\n new_wcs = match_wcs(wcs_img, sky_img, sky_ref, opt_alg)\n update_header_wcs(img_hdu, new_wcs)\n write_fits(hdulist, outfile)\n\ndef test():\n # List of (RA, Dec) for the \"reference\" (correct) positions for 4 sources\n sky_ref = [(130.0048, 29.8197),\n (130.00679, 29.81488),\n (130.01521, 29.81453),\n (130.01099, 29.81773),\n ]\n # List of (RA, Dec) measured in the HST image for the same 4 sources\n sky_img = [(130.00499, 29.81962),\n (130.00693, 29.81473),\n (130.01542, 29.81432),\n (130.01117, 29.81759),\n ]\n\n fix_img_wcs('test.fits', 'test_fix_scipy.fits',\n sky_ref, sky_img, opt_alg='scipy', hdu=0)\n fix_img_wcs('test.fits', 'test_fix_sherpa.fits',\n sky_ref, sky_img, opt_alg='sherpa', hdu=0)\n\n\n", "description": "[<p></p>]", "author": "aldcroft ", "tags": ["FITS", "WCS", "coordinates", "astrometry", "ds9", "PyFITS", "sherpa", "images"], "date_published": "2011-01-13", "title": "Fix the WCS for a FITS image file"}