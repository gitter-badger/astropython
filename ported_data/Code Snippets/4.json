{"code_in_html": "import logging\nimport sys\n\nclass NullHandler(logging.Handler):\n  def emit(self, record):\n    pass\n\ndef config_logger(name, format='%(message)s', datefmt=None,\n         stream=sys.stdout, level=logging.INFO, \n         filename=None, filemode='w', filelevel=None,\n         propagate=False):\n  \"\"\"\n  Do basic configuration for the logging system. Similar to\n  logging.basicConfig but the logger ``name`` is configurable and both a file\n  output and a stream output can be created. Returns a logger object.\n\n  The default behaviour is to create a StreamHandler which writes to\n  sys.stdout, set a formatter using the \"%(message)s\" format string, and\n  add the handler to the ``name`` logger.\n\n  A number of optional keyword arguments may be specified, which can alter\n  the default behaviour.\n\n  :param name: Logger name\n  :param format: handler format string\n  :param datefmt: handler date/time format specifier\n  :param stream: initialize the StreamHandler using ``stream``\n          (None disables the stream, default=sys.stdout)\n  :param level: logger level (default=INFO).\n  :param filename: create FileHandler using ``filename`` (default=None)\n  :param filemode: open ``filename`` with specified filemode ('w' or 'a')\n  :param filelevel: logger level for file logger (default=``level``)\n  :param propagate: propagate message to parent (default=False)\n\n  :returns: logging.Logger object\n  \"\"\"\n  # Get a logger for the specified name\n  logger = logging.getLogger(name)\n  logger.setLevel(level)\n  fmt = logging.Formatter(format, datefmt)\n  logger.propagate = propagate\n\n  # Remove existing handlers, otherwise multiple handlers can accrue\n  for hdlr in logger.handlers:\n    logger.removeHandler(hdlr)\n\n  # Add handlers. Add NullHandler if no file or stream output so that\n  # modules don't emit a warning about no handler.\n  if not (filename or stream):\n    logger.addHandler(NullHandler())\n\n  if filename:\n    hdlr = logging.FileHandler(filename, filemode)\n    if filelevel is None:\n      filelevel = level\n    hdlr.setLevel(filelevel)\n    hdlr.setFormatter(fmt)\n    logger.addHandler(hdlr)\n\n  if stream:\n    hdlr = logging.StreamHandler(stream)\n    hdlr.setLevel(level)\n    hdlr.setFormatter(fmt)\n    logger.addHandler(hdlr)\n\n  return logger\n", "description": "[<p>The python <a href=\"http://docs.python.org/library/logging.html\">logging</a> module is a very good option for producing output in most code and especially in modules that will distributed.\u00a0 It is incredibly flexible but that comes with the price of a steep learning curve.\u00a0 The developers recognized this and included a one-stop method logging.basicConfig() to set up a basic logger that will often suffice for application usage.\u00a0 However, this method only sets up the root logger and does nothing if a root logger is already configured.\u00a0 So it is not really appropriate for use in a module.</p>, <p>Following is a little snippet of code that I have in a module called clogging.py (think of custom-logging).\u00a0 It's inspired by basicConfig() but it requires that you set the name of the logger (something different than root) and includes parameters for the common situation of logging to the screen (stdout) and optionally a file.\u00a0 The file logger can have a different log level to support more detailed output there.</p>, <p></p>, <p>One issue with logging is the default feature of propagating messages to parent loggers.\u00a0 Imagine your module defines a logger called \"mymodule\" and sets the level at INFO.\u00a0 Then an application using your module defines a root logger and likewise sets the level at INFO.\u00a0 Because the root logger is the parent of \"mymodule\", any logging.INFO statements within your module also pass messages through the root logger, potentially generating multiple outputs.\u00a0 Sometimes this is very useful, but in many simple applications you want to keep the module logging distinct from the application logging.\u00a0 In the config_logger() routine this is controlled by the propagate parameter.</p>, <p>To use this in a module you could put something like the following at the module level.\u00a0 This will get executed when the module is imported.</p>, <p>After this users will have the option to control or redirect output from your module with the standard logging interface, e.g.</p>, <p>A friendlier option might be to provide some documented module methods to set the module \"verbosity\".\u00a0 This would do essentially the same as above but hide the hairy details of the logging module.</p>]", "author": "aldcroft ", "tags": [], "date_published": "2010-02-14", "title": "Easier python logging"}