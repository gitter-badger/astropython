{"code_in_html": "#!/usr/bin/env python\n\"\"\" Fast algorithm for spectral analysis of unevenly sampled data\n\nThe Lomb-Scargle method performs spectral analysis on unevenly sampled\ndata and is known to be a powerful way to find, and test the \nsignificance of, weak periodic signals. The method has previously been\nthought to be 'slow', requiring of order 10(2)N(2) operations to analyze\nN data points. We show that Fast Fourier Transforms (FFTs) can be used\nin a novel way to make the computation of order 10(2)N log N. Despite\nits use of the FFT, the algorithm is in no way equivalent to \nconventional FFT periodogram analysis.\n\nKeywords:\n  DATA SAMPLING, FAST FOURIER TRANSFORMATIONS, \n  SPECTRUM ANALYSIS, SIGNAL  PROCESSING\n\nExample:\n  > import numpy\n  > import lomb\n  > x = numpy.arange(10)\n  > y = numpy.sin(x)\n  > fx,fy, nout, jmax, prob = lomb.fasper(x,y, 6., 6.)\n\nReference: \n  Press, W. H. & Rybicki, G. B. 1989\n  ApJ vol. 338, p. 277-280.\n  Fast algorithm for spectral analysis of unevenly sampled data\n  bib code: 1989ApJ...338..277P\n\n\"\"\"\nfrom numpy import *\nfrom numpy.fft import *\n\ndef __spread__(y, yy, n, x, m):\n  \"\"\"\n  Given an array yy(0:n-1), extirpolate (spread) a value y into\n  m actual array elements that best approximate the \"fictional\"\n  (i.e., possible noninteger) array element number x. The weights\n  used are coefficients of the Lagrange interpolating polynomial\n  Arguments:\n    y : \n    yy : \n    n : \n    x : \n    m : \n  Returns:\n    \n  \"\"\"\n  nfac=[0,1,1,2,6,24,120,720,5040,40320,362880]\n  if m > 10. :\n    print 'factorial table too small in spread'\n    return\n\n  ix=long(x)\n  if x == float(ix): \n    yy[ix]=yy[ix]+y\n  else:\n    ilo = long(x-0.5*float(m)+1.0)\n    ilo = min( max( ilo , 1 ), n-m+1 ) \n    ihi = ilo+m-1\n    nden = nfac[m]\n    fac=x-ilo\n    for j in range(ilo+1,ihi+1): fac = fac*(x-j)\n    yy[ihi] = yy[ihi] + y*fac/(nden*(x-ihi))\n    for j in range(ihi-1,ilo-1,-1):\n      nden=(nden/(j+1-ilo))*(j-ihi)\n      yy[j] = yy[j] + y*fac/(nden*(x-j))\n\ndef fasper(x,y,ofac,hifac, MACC=4):\n  \"\"\" function fasper\n    Given abscissas x (which need not be equally spaced) and ordinates\n    y, and given a desired oversampling factor ofac (a typical value\n    being 4 or larger). this routine creates an array wk1 with a\n    sequence of nout increasing frequencies (not angular frequencies)\n    up to hifac times the \"average\" Nyquist frequency, and creates\n    an array wk2 with the values of the Lomb normalized periodogram at\n    those frequencies. The arrays x and y are not altered. This\n    routine also returns jmax such that wk2(jmax) is the maximum\n    element in wk2, and prob, an estimate of the significance of that\n    maximum against the hypothesis of random noise. A small value of prob\n    indicates that a significant periodic signal is present.\n  \n  Reference: \n    Press, W. H. & Rybicki, G. B. 1989\n    ApJ vol. 338, p. 277-280.\n    Fast algorithm for spectral analysis of unevenly sampled data\n    (1989ApJ...338..277P)\n\n  Arguments:\n      X   : Abscissas array, (e.g. an array of times).\n      Y   : Ordinates array, (e.g. corresponding counts).\n      Ofac : Oversampling factor.\n      Hifac : Hifac * \"average\" Nyquist frequency = highest frequency\n           for which values of the Lomb normalized periodogram will\n           be calculated.\n      \n   Returns:\n      Wk1 : An array of Lomb periodogram frequencies.\n      Wk2 : An array of corresponding values of the Lomb periodogram.\n      Nout : Wk1 & Wk2 dimensions (number of calculated frequencies)\n      Jmax : The array index corresponding to the MAX( Wk2 ).\n      Prob : False Alarm Probability of the largest Periodogram value\n      MACC : Number of interpolation points per 1/4 cycle\n            of highest frequency\n\n  History:\n    02/23/2009, v1.0, MF\n      Translation of IDL code (orig. Numerical recipies)\n  \"\"\"\n  #Check dimensions of input arrays\n  n = long(len(x))\n  if n != len(y):\n    print 'Incompatible arrays.'\n    return\n\n  nout  = 0.5*ofac*hifac*n\n  nfreqt = long(ofac*hifac*n*MACC)   #Size the FFT as next power\n  nfreq = 64L             # of 2 above nfreqt.\n\n  while nfreq < nfreqt: \n    nfreq = 2*nfreq\n\n  ndim = long(2*nfreq)\n  \n  #Compute the mean, variance\n  ave = y.mean()\n  ##sample variance because the divisor is N-1\n  var = ((y-y.mean())**2).sum()/(len(y)-1) \n  # and range of the data.\n  xmin = x.min()\n  xmax = x.max()\n  xdif = xmax-xmin\n\n  #extirpolate the data into the workspaces\n  wk1 = zeros(ndim, dtype='complex')\n  wk2 = zeros(ndim, dtype='complex')\n\n  fac  = ndim/(xdif*ofac)\n  fndim = ndim\n  ck  = ((x-xmin)*fac) % fndim\n  ckk  = (2.0*ck) % fndim\n\n  for j in range(0L, n):\n    __spread__(y[j]-ave,wk1,ndim,ck[j],MACC)\n    __spread__(1.0,wk2,ndim,ckk[j],MACC)\n\n  #Take the Fast Fourier Transforms\n  wk1 = ifft( wk1 )*len(wk1)\n  wk2 = ifft( wk2 )*len(wk1)\n\n  wk1 = wk1[1:nout+1]\n  wk2 = wk2[1:nout+1]\n  rwk1 = wk1.real\n  iwk1 = wk1.imag\n  rwk2 = wk2.real\n  iwk2 = wk2.imag\n  \n  df  = 1.0/(xdif*ofac)\n  \n  #Compute the Lomb value for each frequency\n  hypo2 = 2.0 * abs( wk2 )\n  hc2wt = rwk2/hypo2\n  hs2wt = iwk2/hypo2\n\n  cwt  = sqrt(0.5+hc2wt)\n  swt  = sign(hs2wt)*(sqrt(0.5-hc2wt))\n  den  = 0.5*n+hc2wt*rwk2+hs2wt*iwk2\n  cterm = (cwt*rwk1+swt*iwk1)**2./den\n  sterm = (cwt*iwk1-swt*rwk1)**2./(n-den)\n\n  wk1 = df*(arange(nout, dtype='float')+1.)\n  wk2 = (cterm+sterm)/(2.0*var)\n  pmax = wk2.max()\n  jmax = wk2.argmax()\n\n\n  #Significance estimation\n  #expy = exp(-wk2)          \n  #effm = 2.0*(nout)/ofac       \n  #sig = effm*expy\n  #ind = (sig > 0.01).nonzero()\n  #sig[ind] = 1.0-(1.0-expy[ind])**effm\n\n  #Estimate significance of largest peak value\n  expy = exp(-pmax)          \n  effm = 2.0*(nout)/ofac       \n  prob = effm*expy\n\n  if prob > 0.01: \n    prob = 1.0-(1.0-expy)**effm\n\n  return wk1,wk2,nout,jmax,prob\n\ndef getSignificance(wk1, wk2, nout, ofac):\n  \"\"\" returns the peak false alarm probabilities\n  Hence the lower is the probability and the more significant is the peak\n  \"\"\"\n  expy = exp(-wk2)          \n  effm = 2.0*(nout)/ofac       \n  sig = effm*expy\n  ind = (sig > 0.01).nonzero()\n  sig[ind] = 1.0-(1.0-expy[ind])**effm\n  return sig\n\n\n", "description": "[<p>Astropython.org visitor \"Morgan\" contributed a Python implementation of Lomb-Scargle via the comments to <a href=\"http://www.astropython.org/blog/2010/9/Question-period-finding-packages-in-python\">[Question] period-finding packages in python</a>.\u00a0 This script is based on:</p>, <p>\u00a0\u00a0\u00a0 Press, W. H. &amp; Rybicki, G. B. 1989<br/>\u00a0\u00a0\u00a0 ApJ vol. 338, p. 277-280.<br/>\u00a0\u00a0\u00a0 Fast algorithm for spectral analysis of unevenly sampled data<br/>\u00a0\u00a0\u00a0 bib code: 1989ApJ...338..277P</p>, <p>In order to make the script easier to access via cut and paste we are providing it here as a code snippet.\u00a0 This version repairs a couple of apparent issues with indentation in the original comment posting (near the top of the <strong>__spread__</strong> function).</p>, <p></p>]", "author": "aldcroft ", "tags": ["timing", "spectra"], "date_published": "2010-09-27", "title": "Fast Lomb-Scargle algorithm"}